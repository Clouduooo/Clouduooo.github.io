<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>技术美术百人计划-图形向笔记 | Clouduoの博客</title><meta name="author" content="Clouduo"><meta name="copyright" content="Clouduo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="未完待续">
<meta property="og:type" content="article">
<meta property="og:title" content="技术美术百人计划-图形向笔记">
<meta property="og:url" content="https://clouduooo.github.io/2024/10/19/TA-Graphics/index.html">
<meta property="og:site_name" content="Clouduoの博客">
<meta property="og:description" content="未完待续">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://clouduooo.github.io/img/Clouduo.PNG">
<meta property="article:published_time" content="2024-10-18T16:00:00.000Z">
<meta property="article:modified_time" content="2024-10-29T08:43:27.982Z">
<meta property="article:author" content="Clouduo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://clouduooo.github.io/img/Clouduo.PNG"><link rel="shortcut icon" href="/img/Clouduo.PNG"><link rel="canonical" href="https://clouduooo.github.io/2024/10/19/TA-Graphics/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '技术美术百人计划-图形向笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-29 16:43:27'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" integrity="sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+" crossorigin="anonymous"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js" integrity="sha384-7zkQWkzuo3B5mTepMUcHkMB5jZaolc2xDwL6VFqjFALcbeS9Ggm/Yr2r3Dy4lfFg" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous"></script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/Clouduo.PNG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大佬传送门</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/GuraYuriCamp.gif')"><nav id="nav"><span id="blog-info"><a href="/" title="Clouduoの博客"><span class="site-name">Clouduoの博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大佬传送门</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">技术美术百人计划-图形向笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-18T16:00:00.000Z" title="发表于 2024-10-19 00:00:00">2024-10-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-29T08:43:27.982Z" title="更新于 2024-10-29 16:43:27">2024-10-29</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="技术美术百人计划-图形向笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>写在前面</h1>
<p>未学习完…<br>
一些我不会的概念去参考了RTR以及其他人的笔记进行了适当补充<br>
优秀的笔记参考：<br>
<a target="_blank" rel="noopener" href="https://www.yuque.com/xiaohen-ecwjj/vegbg9">百人计划作业 (yuque.com)</a>——by 晓痕</p>
<h1>一. 基础</h1>
<h2 id="1-渲染流水线">1.渲染流水线</h2>
<p>见ppt</p>
<h2 id="2-数学基础">2.数学基础</h2>
<p>见shader入门精要，蛮详细的，但是透视投影矩阵的推导没有细讲</p>
<h2 id="3-纹理介绍">3.纹理介绍</h2>
<h3 id="纹理是什么？">纹理是什么？</h3>
<p>纹理宏观来讲就是一张图片，是一种可供着色器读写的结构化存储形式</p>
<h3 id="纹理管线">纹理管线</h3>
<img src="/2024/10/19/TA-Graphics/image-20240930192324912.png" class="" title="image-20240930192324912">
<p><strong>投影函数</strong>：纹理投影，通常是在建模过程中，展uv阶段使用的，也就是获取模型空间某顶点对应在纹理空间下的坐标位置，并将纹理空间下这个坐标存储在模型顶点数据中</p>
<p><strong>通讯函数</strong>：对上述的纹理坐标进行平移缩放等扩展操作，更新成为新的纹理坐标</p>
<p><strong>纹理采样</strong>：也就是我们在片元着色器中的tex2D函数这种操作<br>
**依赖纹理读取：**只要片元着色器中使用的UV采样坐标不是由顶点着色器传来，而是直接读取运算的，就会发生依赖纹理读取，影响性能</p>
<img src="/2024/10/19/TA-Graphics/image-20240930192943161.png" class="" title="image-20240930192943161">
<p>以上图片是纹理管线的示例，图中纹理大小为256x256，即0.32*256 ~= 81</p>
<h3 id="纹理采样设置">纹理采样设置</h3>
<img src="/2024/10/19/TA-Graphics/image-20240930193102390.png" class="" title="image-20240930193102390">
<p><strong>Filter Mode是纹理在由于变换所导致的拉伸缩放时所采用的一种调整模式</strong></p>
<img src="/2024/10/19/TA-Graphics/image-20240930193214005.png" class="" title="image-20240930193214005">
<p>双线性插值：由最邻近的四个点位的像素值插值得来</p>
<img src="/2024/10/19/TA-Graphics/image-20240930193908148.png" class="" title="image-20240930193908148">
<img src="/2024/10/19/TA-Graphics/image-20240930194304917.png" class="" title="image-20240930194304917">
<img src="/2024/10/19/TA-Graphics/image-20240930194354582.png" class="" title="image-20240930194354582">
<img src="/2024/10/19/TA-Graphics/image-20240930194626722.png" class="" title="image-20240930194626722">
<img src="/2024/10/19/TA-Graphics/image-20240930194845479.png" class="" title="image-20240930194845479">
<h3 id="mipmap">mipmap</h3>
<p>mipmap可以用来解决纹理缩小时导致的纹理采样的颜色丢失等问题</p>
<img src="/2024/10/19/TA-Graphics/image-20240930195344664.png" class="" title="image-20240930195344664">
<h4 id="mipmap的生成原理">mipmap的生成原理</h4>
<p>原理就是基层纹理为原纹理，下一级纹理为原纹理的1/4分辨率，即原纹理中四个相邻像素插值得到一个像素值，只保留该像素，使得原纹理缩小为原来的1/4，再下一级同理。根据等比数列求和可知，最终mipmap存的纹理集大小仅仅比一张原纹理多了1/3的内存</p>
<h4 id="mipmap具体使用时采样level的选择原理">mipmap具体使用时采样level的选择原理</h4>
<p><img src="TA-Graphics/image-20240930200616916.png" alt="image-20240930200616916"><img src="TA-Graphics/image-20240930200655016.png" alt="image-20240930200655016"></p>
<p>在屏幕空间中选取当前像素点右方和上方的两个相邻像素点，分别查询当前点，右方点，上方点，三个点对应在Texture Space纹理空间下的纹理坐标。计算出当前像素点与右方和上方点在纹理空间下的距离，取二者中的最大值，称为L（这里取最大值然后当作一个正方形）。<br>
得出这个最大距离L以后，对其取log2，得到的结果值称为levelD，这个值就是level的选取值<br>
<strong>为什么</strong>：因为算出屏幕上两个像素间在纹理空间下的距离的值L，我们取log2就是查询这个距离值是2的几次方。假如L是2^2^，说明屏幕上两个相邻像素间在纹理中是四个纹素距离，而mipmap生成的level为2的纹理刚好就是由原像素四个为一组合并为一个像素的缩小纹理图，也就是说，在level为2的纹理图中，两个相邻纹素的距离就是四个原纹素距离，刚好可以对应！</p>
<h4 id="三线性插值">三线性插值</h4>
<img src="/2024/10/19/TA-Graphics/image-20240930201301021.png" class="" title="image-20240930201301021">
<p>当我们的levelD是一个小数，说明并没有得到准确对应的那个mipmap纹理图，此时使用三线性插值。也就是下取整的levelD纹理图中使用一次双线性插值，得到一个纹理值，再在上取整的levelD纹理图中进行一次双线性插值。两个纹理值再根据levelD的小数部分进行一次线性插值，得到最终的纹理值。</p>
<h4 id="mipmap的缺陷">mipmap的缺陷</h4>
<img src="/2024/10/19/TA-Graphics/image-20240930201726873.png" class="" title="image-20240930201726873">
<h4 id="各向异性过滤">各向异性过滤</h4>
<img src="/2024/10/19/TA-Graphics/image-20240930201833568.png" class="" title="image-20240930201833568">
<p>是一种方法，也就是不使用正方形的方式进行mipmap预处理操作，而是基于纹理图像特点在不同方向有不同精度进行mipmap生成<br>
也就是使用各自比例的矩形进行缩小纹理的预处理</p>
<img src="/2024/10/19/TA-Graphics/image-20240930202134355.png" class="" title="image-20240930202134355">
<h5 id="积分图Summed-Area-Table">积分图Summed-Area Table</h5>
<p>各向异性过滤的一种实现方式</p>
<img src="/2024/10/19/TA-Graphics/image-20240930205720715.png" class="" title="image-20240930205720715">
<p>没听懂，先放这里</p>
<h4 id="无约束的各向异性过滤——让内存占用也几乎只是多了1-3">无约束的各向异性过滤——让内存占用也几乎只是多了1/3</h4>
<p>以下摘自RTR，这个方法好像就是ue和unity所采用的各向异性过滤的实现方法</p>
<img src="/2024/10/19/TA-Graphics/image-20240930211217912.png" class="" title="image-20240930211217912">
<h4 id="EWA过滤">EWA过滤</h4>
<img src="/2024/10/19/TA-Graphics/image-20240930202212260.png" class="" title="image-20240930202212260">
<h3 id="纹理相关的渲染优化">纹理相关的渲染优化</h3>
<h4 id="CPU上的优化——使用纹理图集-数组">CPU上的优化——使用纹理图集/数组</h4>
<img src="/2024/10/19/TA-Graphics/image-20240930203506020.png" class="" title="image-20240930203506020">
<p>使用纹理图集就是把大量的小纹理合成一张大的纹理，这样draw call时只需要提交一次纹理，减少频繁改变纹理导致的draw call增加</p>
<h4 id="GPU上的优化——纹理压缩">GPU上的优化——纹理压缩</h4>
<img src="/2024/10/19/TA-Graphics/image-20240930203812937.png" class="" title="image-20240930203812937">
<h3 id="常见的纹理">常见的纹理</h3>
<h4 id="CubeMap-立方体纹理">CubeMap 立方体纹理</h4>
<img src="/2024/10/19/TA-Graphics/image-20240930203903494.png" class="" title="image-20240930203903494">
<p>我们从cubemap的立方体中心为原点，选择一个方向发射射线，接触到的点就是采样得到的纹理值。<br>
**具体采样过程：**采样方向矢量三维中选择绝对值最大的那一维，作为我们要取采样的cubemap立方体对应的那个面上的2D纹理图。如上图所示，z值最大，因此我们在cubemap的六个面中应该选择-Z这个面，也就是后方向面的这张纹理贴图！<br>
接下来，我们让x，y分量除以z的绝对值，此时xy转换到了-1~1范围，因此对这个值+1再除以二，将x，y转换到0-1范围，作为后面这张纹理贴图的uv采样坐标！</p>
<h4 id="Bump-Map-凹凸贴图">Bump Map 凹凸贴图</h4>
<img src="/2024/10/19/TA-Graphics/image-20240930204528412.png" class="" title="image-20240930204528412">
<p>这里目前没有给出具体介绍，请参考unity shader入门精要7.2节凹凸映射</p>
<h4 id="Displacement-Map-位移贴图">Displacement Map 位移贴图</h4>
<img src="/2024/10/19/TA-Graphics/image-20240930205043900.png" class="" title="image-20240930205043900">
<p>使用位移贴图的要求：要求表面的顶点数量要很多，如果三角形面的顶点间距离是大于位移贴图定义的顶点距离时（即实际顶点的频率是低于贴图的采样频率），偏移就失效了。<br>
遇到上述情况，可以使用曲面细分，再进行位移贴图采样</p>
<h2 id="4-PC，手机图形API介绍">4.PC，手机图形API介绍</h2>
<h3 id="基础概念">基础概念</h3>
<img src="/2024/10/19/TA-Graphics/image-20240930212155933.png" class="" title="image-20240930212155933">
<p>OpenGL 3.0和2.0 ES的一些改变<img src="/2024/10/19/TA-Graphics/image-20240930212835976.png" class="" title="image-20240930212835976"></p>
<h3 id="骁龙Adreno对应的ES版本型号">骁龙Adreno对应的ES版本型号</h3>
<img src="/2024/10/19/TA-Graphics/image-20240930213125760.png" class="" title="image-20240930213125760">
<h1>二. 光照基础</h1>
<h2 id="1-颜色空间">1.颜色空间</h2>
<h3 id="光的发送者——光源">光的发送者——光源</h3>
<p>光源是产生光的物体。我们对光的认知是一种波长与能量的分布</p>
<h4 id="光的属性——波长">光的属性——波长</h4>
<img src="/2024/10/19/TA-Graphics/image-20241001132020189.png" class="" title="image-20241001132020189">
<h4 id="光的属性——能量分布">光的属性——能量分布</h4>
<img src="/2024/10/19/TA-Graphics/image-20241001132101980.png" class="" title="image-20241001132101980">
<img src="/2024/10/19/TA-Graphics/image-20241001132233988.png" class="" title="image-20241001132233988">
<img src="/2024/10/19/TA-Graphics/image-20241001142048954.png" class="" title="image-20241001142048954">
<img src="/2024/10/19/TA-Graphics/image-20241001132447869.png" class="" title="image-20241001132447869">
<h3 id="光的接收者——人眼">光的接收者——人眼</h3>
<h4 id="相对亮度感知">相对亮度感知</h4>
<p>在阴暗环境下人眼对亮度变化的感知更加明显<br>
比如，在全黑环境下点亮一盏灯的感受比在有一盏灯时点亮100盏灯的感受更强烈</p>
<h4 id="人眼HDR">人眼HDR</h4>
<p>人眼在亮部中仍然可以区分出细节上的区别，在暗部也能区分出细节层次。但目前图形学，或者说目前的摄影都做不到，一张照片很难同时拥有高光细节和暗部细节</p>
<h4 id="人眼感光细胞分布">人眼感光细胞分布</h4>
<p>人眼可以把感知色彩的细胞分为两大类，<strong>杆状细胞</strong>和<strong>锥状细胞</strong><br>
杆状细胞：感知亮度，只要有5-14个光子打到杆状细胞就会产生神经信号给大脑<br>
锥状细胞：感知色彩</p>
<h4 id="锥状细胞">锥状细胞</h4>
<img src="/2024/10/19/TA-Graphics/image-20241001133414172.png" class="" title="image-20241001133414172">
<h4 id="人眼的本质">人眼的本质</h4>
<p>人眼的本质就是光源的接收者，作用是接受外部光线输入，输出神经电信号给大脑</p>
<h4 id="人眼接收光的微积分公式">人眼接收光的微积分公式</h4>
<img src="/2024/10/19/TA-Graphics/image-20241001133616201.png" class="" title="image-20241001133616201">
<img src="/2024/10/19/TA-Graphics/image-20241001133622694.png" class="" title="image-20241001133622694">
<h3 id="颜色空间的历史">颜色空间的历史</h3>
<h4 id="1800年——色彩的猜想-swig￼36">1800年——色彩的猜想<img src="/2024/10/19/TA-Graphics/image-20241001134008000.png" class="" title="image-20241001134008000"></h4>
<h4 id="1905年——Munsell艺术家色彩系统">1905年——Munsell艺术家色彩系统</h4>
<img src="/2024/10/19/TA-Graphics/image-20241001134122051.png" class="" title="image-20241001134122051">
<h4 id="1931年——CIE建立科学色彩系统">1931年——CIE建立科学色彩系统</h4>
<img src="/2024/10/19/TA-Graphics/image-20241001134604109.png" class="" title="image-20241001134604109">
<p>通过不断调整RGB光源的值，直到观察者认为下白板和上白板上颜色一致，这时我们就得到一个特定的颜色对应什么RGB的混合。</p>
<img src="/2024/10/19/TA-Graphics/image-20241001135007803.png" class="" title="image-20241001135007803">
<img src="/2024/10/19/TA-Graphics/image-20241001135024727.png" class="" title="image-20241001135024727">
<img src="/2024/10/19/TA-Graphics/image-20241001135201646.png" class="" title="image-20241001135201646">
<img src="/2024/10/19/TA-Graphics/image-20241001135216104.png" class="" title="image-20241001135216104">
<img src="/2024/10/19/TA-Graphics/image-20241001135526216.png" class="" title="image-20241001135526216">
<img src="/2024/10/19/TA-Graphics/image-20241001135550391.png" class="" title="image-20241001135550391">
<img src="/2024/10/19/TA-Graphics/image-20241001135607700.png" class="" title="image-20241001135607700">
<p>可见，这个Y坐标代表的亮度，而xy组成的二维空间就是上图的色域马蹄图</p>
<img src="/2024/10/19/TA-Graphics/image-20241001135732366.png" class="" title="image-20241001135732366">
<h4 id="色彩空间的定义">色彩空间的定义</h4>
<h5 id="1-色域">1.色域</h5>
<p>决定RGB三原色的坐标位置（形成色彩空间三角形的三个顶点和边界）</p>
<h5 id="2-Gamma">2.Gamma</h5>
<p>gamma是对色彩空间进行采样的一种方式，或者说对色彩空间的一种切分方式，从色域三角形边界向内部白点方向进行切分</p>
<p>拿shader入门精要中伽马矫正部分来理解，也是是一样的道理——人眼对暗部颜色的区分感知更明显，对亮度高的颜色的感知不那么明显，因此如果gamma = 1的线性方式区分颜色值，会有浪费。我们应该多花一些内存来表示较暗的颜色的颜色值，较亮的可以少一些，因此出现了gamma != 1 的非线性颜色空间切分方式，但是这样非线性色彩空间切分方式会导致我们的颜色混合等操作在非线性空间中进行，这样显然会有问题。为了解决非线性空间问题，我们会使用一种变换，把非线性空间颜色转换成到线性空间中，得到一种Linear Space Color，这样再做操作就没问题了，这个步骤一般是unity帮我们做，这也就是伽马矫正<br>
也就是说，gamma切分了色域，使得颜色更合理存储，但是gamma非线性时会带来我们渲染的问题，因此需要进行伽马矫正，得到线性空间让我们进行渲染</p>
<img src="/2024/10/19/TA-Graphics/image-20241001140214075.png" class="" title="image-20241001140214075">
<img src="/2024/10/19/TA-Graphics/image-20241001140255807.png" class="" title="image-20241001140255807">
<img src="/2024/10/19/TA-Graphics/image-20241001140835475.png" class="" title="image-20241001140835475">
<h5 id="3-白点">3.白点</h5>
<p>白点是色域三角形的中心点，也是颜色明度最亮的点</p>
<h4 id="sRGB色彩空间">sRGB色彩空间</h4>
<img src="/2024/10/19/TA-Graphics/image-20241001140438282.png" class="" title="image-20241001140438282">
<h4 id="常用的色彩空间">常用的色彩空间</h4>
<img src="/2024/10/19/TA-Graphics/image-20241001141251019.png" class="" title="image-20241001141251019">
<h2 id="2-模型与材质">2.模型与材质</h2>
<h3 id="渲染管线与模型基础">渲染管线与模型基础</h3>
<h4 id="与模型相关的渲染管线">与模型相关的渲染管线</h4>
<img src="/2024/10/19/TA-Graphics/image-20241007225624532.png" class="" title="image-20241007225624532">
<h4 id="模型携带的信息">模型携带的信息</h4>
<img src="/2024/10/19/TA-Graphics/image-20241007225700905.png" class="" title="image-20241007225700905">
<img src="/2024/10/19/TA-Graphics/image-20241007225847982.png" class="" title="image-20241007225847982">
<h3 id="材质基础">材质基础</h3>
<h4 id="材质是什么">材质是什么</h4>
<img src="/2024/10/19/TA-Graphics/image-20241007230019866.png" class="" title="image-20241007230019866">
<h4 id="漫反射">漫反射</h4>
<img src="/2024/10/19/TA-Graphics/image-20241007230111424.png" class="" title="image-20241007230111424">
<h4 id="镜面反射">镜面反射</h4>
<img src="/2024/10/19/TA-Graphics/image-20241007230120040.png" class="" title="image-20241007230120040">
<h4 id="折射">折射</h4>
<img src="/2024/10/19/TA-Graphics/image-20241007230131784.png" class="" title="image-20241007230131784">
<h4 id="粗糙镜面反射">粗糙镜面反射</h4>
<img src="/2024/10/19/TA-Graphics/image-20241007230225420.png" class="" title="image-20241007230225420">
<h4 id="粗糙镜面折射">粗糙镜面折射</h4>
<img src="/2024/10/19/TA-Graphics/image-20241007230256208.png" class="" title="image-20241007230256208">
<h4 id="多层纹理">多层纹理</h4>
<img src="/2024/10/19/TA-Graphics/image-20241007230348529.png" class="" title="image-20241007230348529">
<h4 id="次表面散射">次表面散射</h4>
<img src="/2024/10/19/TA-Graphics/image-20241007230412263.png" class="" title="image-20241007230412263">
<h4 id="多层皮肤模型">多层皮肤模型</h4>
<img src="/2024/10/19/TA-Graphics/image-20241007230441858.png" class="" title="image-20241007230441858">
<h4 id="改变材质表面的方法">改变材质表面的方法</h4>
<img src="/2024/10/19/TA-Graphics/image-20241007230537752.png" class="" title="image-20241007230537752">
<h3 id="模型携带的数据再渲染中的作用">模型携带的数据再渲染中的作用</h3>
<h4 id="1-顶点动画">1.顶点动画</h4>
<img src="/2024/10/19/TA-Graphics/image-20241007233208398.png" class="" title="image-20241007233208398">
<img src="/2024/10/19/TA-Graphics/vertex.gif" class="" title="vertex">
<h4 id="2-纹理动画">2.纹理动画</h4>
<p>渲染的过程中改变纹理坐标，使其采样时发生偏移，来达到动画的效果</p>
<img src="/2024/10/19/TA-Graphics/1640354732724-52fc1316-ac5c-49a9-9f7d-993af75f8929.gif" class="" title="111.gif">
<p>水面效果的原理如下：<br>
原理一：光照计算——反射和折射得到颜色再进行扰动的效果<br>
利用法线贴图，改变法线方向，进而改变反射和折射的方向</p>
<img src="/2024/10/19/TA-Graphics/1618187322858-0cc7422c-b910-4338-8eb7-d8ea7112a6e2.webp" class="" title="image.png">
<p>原理二：水面本身贴图进行uv坐标偏移实现水面移动动画效果<br>
改变uv采样点的位置，产生uv纹理动画效果</p>
<img src="/2024/10/19/TA-Graphics/1618187382197-f60bb4c3-2453-4c34-a28d-c616fb8db320.webp" class="" title="image.png">
<h4 id="3-顶点色">3.顶点色</h4>
<p>eg，顶点色达到一定的值，就做阴影</p>
<img src="/2024/10/19/TA-Graphics/image-20241007232543958.png" class="" title="image-20241007232543958">
<p>eg2：使用模型的顶点色作为mask使用</p>
<h4 id="4-插值：重心坐标">4.插值：重心坐标</h4>
<p>重心坐标插值在光栅化阶段进行，这里的x，y可以理解为屏幕坐标<br>
<strong>重心坐标不能保证投影后不变，所以应该先在三维情况下找到重心坐标再插值</strong><br>
利用这个公式可以得到当前像素点的顶点颜色、法线、纹理坐标，然后就能通过周围三个顶点进行插值</p>
<img src="/2024/10/19/TA-Graphics/1618188704173-7241c96d-0b29-49b6-b696-54e620c9527e.webp" class="" title="image.png">
<h4 id="5-顶点法线，面法线">5.顶点法线，面法线</h4>
<img src="/2024/10/19/TA-Graphics/1640356879934-4c62e747-99a7-4baf-9bed-f866b37ea39d.webp" class="" title="image.png">
<p>面法线本质上还是顶点法线，只是存储方式不同</p>
<p><strong>面法线</strong>：三个顶点共用一个法线，插值出来结果相同</p>
<p><strong>顶点法线</strong>：每个顶点都有一个发现，插值出来也就不同</p>
<img src="/2024/10/19/TA-Graphics/1618189881008-f26be23b-e1d9-4e21-9278-a55414453363.webp" class="" title="image.png">
<h4 id="扩展：NPR渲染中的描边">扩展：NPR渲染中的描边</h4>
<img src="/2024/10/19/TA-Graphics/image-20241007233107122.png" class="" title="image-20241007233107122">
<h4 id="作业——copy自-苏格拉没有底">作业——copy自 苏格拉没有底</h4>
<h5 id="1-顶点色的其他作用">1.顶点色的其他作用</h5>
<ul>
<li>
<p>补充：</p>
</li>
<li>
<ul>
<li>最常用的：作为一种存储的mask使用（这样可以少使用一张图）</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>e.g1：不想让脸上有菲涅尔效应，就把脸涂黑，乘上顶点色</li>
<li>e.g2：不想让某些地方有描边，可以如法炮制</li>
<li>e.g3：想把其它信息塞入顶点色。</li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>准则：塞入顶点色的信息必须是线性变化的，如果不是，就要做好精度打折的准备。</li>
</ul>
</li>
<li>
<p>可用于预先指定照明、阻光和其他视觉效果。</p>
</li>
<li>
<p>就是把颜色信息存在顶点里，但是在低模的情况下效果很差。</p>
</li>
<li>
<p>3ds Max 中的所有对象都具有贴图通道，其中保存关于纹理贴图以及顶点颜色、照明和 Alpha 的信息。网格对象同样具有几何体和顶点选择通道。</p>
</li>
<li>
<ul>
<li>主通道为顶点颜色，这可以使对象中的每个顶点都有其自己的颜色，并且在顶点之间自动渐变。此着色默认情况下不可见，但您可以通过“对象属性”设置切换其显示。还可以通过“顶点绘制”修改器等各种功能查看和编辑顶点着色。它可用于预先指定照明、阻光和其他视觉效果。贴图通道数据也可由如游戏引擎等外部应用程序使用。</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.ddove.com/edu/chapter/8123.html">https://www.ddove.com/edu/chapter/8123.html</a></p>
<h5 id="2-模型光滑组对法线有什么影响">2.模型光滑组对法线有什么影响</h5>
<p>①先搞清楚光滑组是什么</p>
<ul>
<li>
<p>没有真正的光滑面，所有面都是三角形</p>
</li>
<li>
<p><strong>光滑组的含义</strong>：下面图标出了面的亮度，纯属打比方，不是确切数字，两面之间的过渡就是两面亮度和的平均值，光滑组处理面之间的光照信息，提高它们的亮度、饱和度。</p>
</li>
<li>
<img src="/2024/10/19/TA-Graphics/1618192732985-2b9fde8a-6e1f-4b2c-b8dc-816a5b0af416.png" class="" title="img">
</li>
<li>
<ul>
<li>如果两个面一个光滑组是1，另一个是2，就不进行计算</li>
<li>如果他们的光滑组都是1，就会进行光照计算，产生光滑效果，影响最终渲染。</li>
<li>
<img src="/2024/10/19/TA-Graphics/1618192956096-b0327c23-9103-4ca7-b361-b2f488a1359d.png" class="" title="img">
</li>
</ul>
</li>
<li>
<p>自动光滑：所有面的夹角小于45度的进行光滑</p>
</li>
<li>
<p><strong>光滑组</strong>：通过处理面之间的光照信息来达到光滑效果，是用来设置边缘线的光滑显示的。</p>
</li>
<li>
<p><strong>网格平滑和涡轮平滑</strong>：通过增加面，把面分的更细腻来表达曲度</p>
</li>
<li>
<p>我们平常说的布线合理，拓朴其实是保持两个三角面的一致性（构成一个四边面的俩三角面）</p>
</li>
</ul>
<p>②光滑组对法线的影响<br>
法线</p>
<ul>
<li>烘焙法线的意义，就是把高模的法线方向，用一张图（RGB）来存储法线信息，存到低模的表面上。贴上法线贴图的低模，就会在视觉上产生凹凸不平、增加细节的渲染效果，从而看起来像高模一样。Normal Mapping 法线贴图本质上就是一种图片，只是这张图片的用途比较特殊而已。</li>
<li>没有光滑组的话，烘出来的法线贴图是一棱一棱的。一般情况下最少也要给一个光滑组</li>
<li>参考链接中的例子：渐变色的法线贴图在substancepainter会出现黑边情况（光滑组的问题）</li>
</ul>
<p>光滑组（软硬边）和UV对法线的影响</p>
<ul>
<li></li>
</ul>
<img src="/2024/10/19/TA-Graphics/1618193680557-57f3f52a-5d58-4ab9-bd08-c20ad47af1d0.jpeg" class="" title="img">
<ul>
<li>光滑组相连的模型，法线贴图都存在大渐变色，导致模型的法线效果会很奇怪（平面上有发暗发亮的光影）。<strong>当你发现你的模型出现这种渐变时，一定是出现了光滑组的问题。</strong></li>
<li>中间的两个模型出现了不同程度的接缝（第三个模型的接缝非常明显，第二个模型则弱一些）。<strong>光滑组和uv统一相连或断开，是不会出现明显接缝的，当遇到接缝问题，优先考虑模型的光滑组和uv是否统一。</strong></li>
<li>
<img src="/2024/10/19/TA-Graphics/1618194009262-57af8855-bf95-4d41-acde-548470904f34.jpeg" class="" title="img">
</li>
</ul>
<h2 id="3-基础语法介绍——HLSL">3.基础语法介绍——HLSL</h2>
<h3 id="1-基本数学运算">1.基本数学运算</h3>
<img src="/2024/10/19/TA-Graphics/image-20241008133026262.png" class="" title="image-20241008133026262">
<p>radians打错了<br>
noise(x)这里的形参是一个二维向量，对应一个点坐标，返回一个噪声值</p>
<h3 id="2-幂指对函数">2.幂指对函数</h3>
<img src="/2024/10/19/TA-Graphics/image-20241008133228422.png" class="" title="image-20241008133228422">
<p>ret是尾数，exp是指数，frexp是把一个浮点数存为计算机中二进制浮点数形式，分别得到尾数和指数（二进制形式）</p>
<h3 id="3-三角函数和双曲函数">3.三角函数和双曲函数</h3>
<img src="/2024/10/19/TA-Graphics/image-20241008134531902.png" class="" title="image-20241008134531902">
<img src="/2024/10/19/TA-Graphics/image-20241008141136437.png" class="" title="image-20241008141136437">
<p>双曲正余弦的几何定义：<br>
如图中，正余弦的几何定义是单位圆定义的。<br>
双曲正余弦就是单位圆上对应的正余弦边延长与双曲线相交点所定义</p>
<h3 id="4-数据范围类">4.数据范围类</h3>
<img src="/2024/10/19/TA-Graphics/image-20241008141527967.png" class="" title="image-20241008141527967">
<p>fmod(x,y) = x % y 这里是取模，符号跟被除数x相同<br>
saturate几乎不耗资源，clamp有一定开销（弹幕）</p>
<h3 id="5-类型判断类">5.类型判断类</h3>
<img src="/2024/10/19/TA-Graphics/image-20241008142833725.png" class="" title="image-20241008142833725">
<h3 id="6-向量与矩阵类">6.向量与矩阵类</h3>
<img src="/2024/10/19/TA-Graphics/image-20241008143301773.png" class="" title="image-20241008143301773">
<p>这里的distance的定义使用了点之间的距离公式计算，但是也可以用于向量计算（至于其是否有意义就不清楚了）</p>
<h3 id="7-光线运算类">7.光线运算类</h3>
<img src="/2024/10/19/TA-Graphics/image-20241008143809961.png" class="" title="image-20241008143809961">
<p>lit函数的具体说明如下：使用了Blinn-Phong光照模型</p>
<img src="/2024/10/19/TA-Graphics/1640362425032-91f18b27-24be-459c-90da-f3931b7bdcdb.webp" class="" title="image.png">
<h3 id="8-1D纹理查找">8.1D纹理查找</h3>
<img src="/2024/10/19/TA-Graphics/image-20241008150053709.png" class="" title="image-20241008150053709">
<h4 id="ddx和ddy解析">ddx和ddy解析</h4>
<img src="/2024/10/19/TA-Graphics/image-20241008150123075.png" class="" title="image-20241008150123075">
<p>ddx，ddy在上图tex2D中的作用是，只有相邻屏幕像素对应到纹理纹素差值大于给定的ddx值时，才进行采样，ddy同理</p>
<h3 id="9-2D纹理查找">9.2D纹理查找</h3>
<img src="/2024/10/19/TA-Graphics/image-20241008150139287.png" class="" title="image-20241008150139287">
<h3 id="10-3D纹理查找">10.3D纹理查找</h3>
<img src="/2024/10/19/TA-Graphics/image-20241008150206818.png" class="" title="image-20241008150206818">
<h3 id="11-CubeMap纹理查找">11.CubeMap纹理查找</h3>
<img src="/2024/10/19/TA-Graphics/image-20241008150236266.png" class="" title="image-20241008150236266">
<h3 id="作业">作业</h3>
<h4 id="ddx和ddy的实际用处——苏格拉没有底">ddx和ddy的实际用处——苏格拉没有底</h4>
<img src="/2024/10/19/TA-Graphics/image-20241008150326501.png" class="" title="image-20241008150326501">
<img src="/2024/10/19/TA-Graphics/%E5%81%8F%E5%AF%BC.gif" class="" title="偏导">
<h2 id="4-传统经验光照模型">4.传统经验光照模型</h2>
<h3 id="局部光照模型">局部光照模型</h3>
<h4 id="局部光源的定义">局部光源的定义</h4>
<p>只关心直接光照部分，即光源发出到物体表面经过反射至摄像头的光线</p>
<p>局部光照可以分为四个部分 漫反射，高光反射，环境光，自发光</p>
<h4 id="漫反射-2">漫反射</h4>
<img src="/2024/10/19/TA-Graphics/image-20241009140107513.png" class="" title="image-20241009140107513">
<h5 id="Lambert余弦定理">Lambert余弦定理</h5>
<img src="/2024/10/19/TA-Graphics/image-20241009140123686.png" class="" title="image-20241009140123686">
<h4 id="高光反射">高光反射</h4>
<img src="/2024/10/19/TA-Graphics/image-20241009140224732.png" class="" title="image-20241009140224732">
<img src="/2024/10/19/TA-Graphics/image-20241009140426217.png" class="" title="image-20241009140426217">
<img src="/2024/10/19/TA-Graphics/image-20241009140441575.png" class="" title="image-20241009140441575">
<h4 id="环境光">环境光</h4>
<img src="/2024/10/19/TA-Graphics/image-20241009140501052.png" class="" title="image-20241009140501052">
<h4 id="自发光">自发光</h4>
<img src="/2024/10/19/TA-Graphics/image-20241009140538027.png" class="" title="image-20241009140538027">
<h4 id="局部光照的整体效果">局部光照的整体效果</h4>
<img src="/2024/10/19/TA-Graphics/image-20241009140609653.png" class="" title="image-20241009140609653">
<h4 id="1-Lambert模型">1.Lambert模型</h4>
<img src="/2024/10/19/TA-Graphics/image-20241009140653934-1728454014925-1.png" class="" title="image-20241009140653934">
<h4 id="2-Phong模型">2.Phong模型</h4>
<img src="/2024/10/19/TA-Graphics/image-20241009140941480.png" class="" title="image-20241009140941480">
<h4 id="3-Blinn-Phong模型">3.Blinn-Phong模型</h4>
<img src="/2024/10/19/TA-Graphics/image-20241009141305297.png" class="" title="image-20241009141305297">
<h4 id="Phong和Blinn-Phong模型的区别">Phong和Blinn-Phong模型的区别</h4>
<img src="/2024/10/19/TA-Graphics/image-20241009141416592.png" class="" title="image-20241009141416592">
<h3 id="着色模型">着色模型</h3>
<h4 id="Gouraud-Shading——顶点着色">Gouraud Shading——顶点着色</h4>
<img src="/2024/10/19/TA-Graphics/image-20241009141643874.png" class="" title="image-20241009141643874">
<h4 id="Flat-Shading——面着色">Flat Shading——面着色</h4>
<img src="/2024/10/19/TA-Graphics/image-20241009141812516.png" class="" title="image-20241009141812516">
<h4 id="Phong-Shading——片元着色">Phong Shading——片元着色</h4>
<p>逐片元着色</p>
<img src="/2024/10/19/TA-Graphics/2311052-20220114234237218-1901636367.png" class="" title="img">
<h3 id="IBL——基于图像的光照">IBL——基于图像的光照</h3>
<p>基于图像的光照(Image based lighting, IBL)是一类光照技术的集合。其光源不是如[前一节教程](<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/07">https://learnopengl-cn.github.io/07</a> PBR/02 Lighting/)中描述的可分解的直接光源，而是将周围环境整体视为一个大光源。IBL 通常使用（取自现实世界或从3D场景生成的）环境立方体贴图 (Cubemap) ，我们可以将立方体贴图的每个像素视为光源，在渲染方程中直接使用它。这种方式可以有效地捕捉环境的全局光照和氛围，使物体<strong>更好地融入</strong>其环境。</p>
<p>由于基于图像的光照算法会捕捉部分甚至全部的环境光照，通常认为它是一种更精确的环境光照输入格式，甚至也可以说是一种全局光照的粗略近似。基于此特性，IBL 对 PBR 很有意义，因为当我们将环境光纳入计算之后，物体在物理方面看起来会更加准确。</p>
<h2 id="5-Bump-Map的改进">5.Bump Map的改进</h2>
<h3 id="什么是凹凸映射">什么是凹凸映射</h3>
<img src="/2024/10/19/TA-Graphics/image-20241010145214987.png" class="" title="image-20241010145214987">
<p>凹凸映射的常见方法是法线映射，视差映射，浮雕映射</p>
<h3 id="Normal-Mapping-法线映射">Normal Mapping 法线映射</h3>
<img src="/2024/10/19/TA-Graphics/image-20241010145447157.png" class="" title="image-20241010145447157">
<img src="/2024/10/19/TA-Graphics/image-20241010145941311.png" class="" title="image-20241010145941311">
<h4 id="切线空间到世界空间转换">切线空间到世界空间转换</h4>
<img src="/2024/10/19/TA-Graphics/image-20241010151047075.png" class="" title="image-20241010151047075">
<p>c：children子空间<br>
p：parent父空间<br>
xc：子空间中x坐标轴在父空间下的表示<br>
yc：子空间中y坐标轴在父空间下的表示<br>
Oc：子空间中坐标原点在父空间下的表示<br>
该矩阵就是子空间-&gt;父空间的转换矩阵</p>
<p>对于切线空间来说，切线Tangent是x轴，副切线Binormal是y轴，法线Normal是z轴<br>
所以切线空间到世界空间变换矩阵一般记作TBN矩阵，就是把T,B,N作为x，y，z如上 列组合起来<br>
世界空间到切线空间变换就是TBN的转置，因为TBN是个正交阵</p>
<img src="/2024/10/19/TA-Graphics/1623110676162-f627267d-65a5-4a26-ad9d-5d39e712abe5.webp" class="" title="image.png">
<h4 id="切线空间的好处">切线空间的好处</h4>
<p>法线存在各个空间里都可以</p>
<p>存放在切线空间下的好处：</p>
<ul>
<li>
<ul>
<li>自由度高。</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>模型空间下是绝对法线信息（仅可以用在创建它时的那个模型）</li>
<li>而切线空间下的是相对法线信息，是对当前物体法线的扰动。（可以复用）</li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>可进行uv动画。</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>比如：移动uv坐标来实现凹凸移动效果</li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>可以重用法线纹理。</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>比如：一个立方体，6个面可以用一张法线贴图</li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>可压缩。</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>由于切线空间下贴图中法线的Z方向总是正方向（模型空间下可以是负的），那么我们只存XY（切线和副切线）就能推出Z（法线）了，可以少存一个。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Unity中法线贴图的压缩格式">Unity中法线贴图的压缩格式</h4>
<img src="/2024/10/19/TA-Graphics/image-20241010151908859.png" class="" title="image-20241010151908859">
<p>上面写错了，GA存储的是法线的yx分量</p>
<img src="/2024/10/19/TA-Graphics/1623113955939-f96c4310-f396-4b94-8b11-31f01b5b59c9.webp" class="" title="img">
<ul>
<li>
<p><strong>关于解码法线贴图时要做一个“*2-1”的操作的解释</strong></p>
</li>
<li>
<ul>
<li>
<ul>
<li><strong>法线纹理</strong>中<strong>存的就是表面法线</strong>，由于法线分量范围为[-1,1]，像素的分量范围为[0,1] 因此我们通常需要做一个映射：pixel=（normal+1）/2，解码时就要做一个反向的操作</li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>关于normal.xy *= scale；的解释</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>是对法线的扰动效果进行缩放</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/2024/10/19/TA-Graphics/1632538316184-f2a5f6ad-6f54-42da-b857-b18dd730c38b.webp" class="" title="image.png">
<h3 id="Parallax-Mapping-视差映射">Parallax Mapping 视差映射</h3>
<img src="/2024/10/19/TA-Graphics/image-20241010153132927.png" class="" title="image-20241010153132927">
<p>要求是顶点数量较多的模型，效果才会显著</p>
<h4 id="视差映射基本实现">视差映射基本实现</h4>
<img src="/2024/10/19/TA-Graphics/image-20241010154027706.png" class="" title="image-20241010154027706">
<img src="/2024/10/19/TA-Graphics/image-20241010154045658.png" class="" title="image-20241010154045658">
<img src="/2024/10/19/TA-Graphics/image-20241010160827640.png" class="" title="image-20241010160827640">
<h4 id="陡峭视差映射">陡峭视差映射</h4>
<img src="/2024/10/19/TA-Graphics/image-20241010154625031.png" class="" title="image-20241010154625031">
<p>比如我要采样视角看向的A点的实际值，查询高度图发现其高度是约0.75，但是视线达到的点高度为0，因此逐层步进，直到一个点的高度大于等于0.75时停止，该点的uv值就是A的实际值</p>
<img src="/2024/10/19/TA-Graphics/image-20241010154858113.png" class="" title="image-20241010154858113">
<h3 id="Relief-Mapping-浮雕映射">Relief Mapping 浮雕映射</h3>
<img src="/2024/10/19/TA-Graphics/image-20241010155333120.png" class="" title="image-20241010155333120">
<img src="/2024/10/19/TA-Graphics/image-20241010155552599.png" class="" title="image-20241010155552599">
<p>浮雕是时差的改良版，减少开销，增加精确度。但仍然是一种近似和欺骗眼睛的效果</p>
<h2 id="6-Gamma矫正">6.Gamma矫正</h2>
<h3 id="什么是Gamma矫正">什么是Gamma矫正</h3>
<img src="/2024/10/19/TA-Graphics/image-20241009150625791.png" class="" title="image-20241009150625791">
<img src="/2024/10/19/TA-Graphics/image-20241009150649541.png" class="" title="image-20241009150649541">
<h3 id="为什么需要Gamma编码和矫正">为什么需要Gamma编码和矫正</h3>
<img src="/2024/10/19/TA-Graphics/image-20241009150827156.png" class="" title="image-20241009150827156">
<p>所以编码时是一个上凸的曲线，为了给暗部颜色更多空间存储，精度更大！</p>
<p>请见下图，实际上下面那条线才是物理上亮度均匀增加的，但我们的人眼却不这么认为！</p>
<img src="/2024/10/19/TA-Graphics/image-20241009150926834.png" class="" title="image-20241009150926834">
<img src="/2024/10/19/TA-Graphics/image-20241009151047133.png" class="" title="image-20241009151047133">
<p>韦伯定律：我们对某种事物的感觉的刺激量会随着刺激的增加而减小感知变化的程度</p>
<h3 id="CRT——阴极射线显像管">CRT——阴极射线显像管</h3>
<img src="/2024/10/19/TA-Graphics/image-20241009151357975.png" class="" title="image-20241009151357975">
<p>CRT的特性自动给我们进行了gamma矫正，因此我们使用gamma编码后再用CRT输出就是很合理的色彩，非常巧</p>
<h3 id="中灰值">中灰值</h3>
<p>值得注意的是，在gamma编码和矫正都确定的条件下，我们取的一个中灰值，在人眼观察下也不是一个特定值<br>
请见下二图，A,B区域实际上是同样的颜色和亮度</p>
<img src="/2024/10/19/TA-Graphics/image-20241009151856003.png" class="" title="image-20241009151856003">
<img src="/2024/10/19/TA-Graphics/image-20241009151908724.png" class="" title="image-20241009151908724">
<h3 id="线性工作流">线性工作流</h3>
<img src="/2024/10/19/TA-Graphics/image-20241009152057531.png" class="" title="image-20241009152057531">
<img src="/2024/10/19/TA-Graphics/image-20241009152201759.png" class="" title="image-20241009152201759">
<img src="/2024/10/19/TA-Graphics/image-20241009152309941.png" class="" title="image-20241009152309941">
<h4 id="Unity中选择颜色空间">Unity中选择颜色空间</h4>
<img src="/2024/10/19/TA-Graphics/image-20241009152409645.png" class="" title="image-20241009152409645">
<img src="/2024/10/19/TA-Graphics/image-20241009152457592.png" class="" title="image-20241009152457592">
<img src="/2024/10/19/TA-Graphics/image-20241009152512353.png" class="" title="image-20241009152512353">
<h4 id="SubstancePainter导出的贴图">SubstancePainter导出的贴图</h4>
<img src="/2024/10/19/TA-Graphics/image-20241009152636198.png" class="" title="image-20241009152636198">
<h4 id="PhotoShop导出的贴图">PhotoShop导出的贴图</h4>
<img src="/2024/10/19/TA-Graphics/image-20241009152718587.png" class="" title="image-20241009152718587">
<h2 id="7-LDR和HDR">7.LDR和HDR</h2>
<h3 id="动态范围">动态范围</h3>
<p>动态范围 = 最高亮度 / 最低亮度</p>
<h3 id="基本概念">基本概念</h3>
<p>HDR——High Dynamic Range 高动态范围<br>
LDR——Low Dynamic Range 低动态范围</p>
<p>将自然界中很亮的光如太阳光颜色（HDR中的亮度），转换到屏幕能显示的最大亮度值（LDR中的亮度），这个过程叫<strong>Tone Mapping</strong></p>
<img src="/2024/10/19/TA-Graphics/image-20241009155027612.png" class="" title="image-20241009155027612">
<h3 id="为什么需要HDR">为什么需要HDR</h3>
<p>1.为了超过1的亮度的色彩也能有很好的细节表现</p>
<img src="/2024/10/19/TA-Graphics/image-20241009155509409.png" class="" title="image-20241009155509409">
<p>2.可以利用HDR超过1的颜色值实现光晕效果（Bloom）！</p>
<img src="/2024/10/19/TA-Graphics/image-20241009155550559.png" class="" title="image-20241009155550559">
<img src="/2024/10/19/TA-Graphics/image-20241009155641003.png" class="" title="image-20241009155641003">
<h3 id="Unity中的HDR">Unity中的HDR</h3>
<img src="/2024/10/19/TA-Graphics/image-20241009155701923.png" class="" title="image-20241009155701923">
<img src="/2024/10/19/TA-Graphics/image-20241009155740517.png" class="" title="image-20241009155740517">
<img src="/2024/10/19/TA-Graphics/image-20241009155812609.png" class="" title="image-20241009155812609">
<img src="/2024/10/19/TA-Graphics/image-20241009155838249.png" class="" title="image-20241009155838249">
<h3 id="HDR和Bloom">HDR和Bloom</h3>
<p>1.渲染原图</p>
<img src="/2024/10/19/TA-Graphics/image-20241009155928268.png" class="" title="image-20241009155928268">
<p>2.渲染超出阈值的高光颜色的图</p>
<img src="/2024/10/19/TA-Graphics/image-20241009155956941.png" class="" title="image-20241009155956941">
<p>3.对高光颜色图进行高斯模糊</p>
<img src="/2024/10/19/TA-Graphics/image-20241009160018361.png" class="" title="image-20241009160018361">
<p>4.叠加高斯模糊后的高光图和原图得到最终结果</p>
<img src="/2024/10/19/TA-Graphics/image-20241009160043071.png" class="" title="image-20241009160043071">
<h4 id="Unity中Bloom的流程">Unity中Bloom的流程</h4>
<img src="/2024/10/19/TA-Graphics/image-20241009160120952.png" class="" title="image-20241009160120952">
<p>在第一步down sample处计算高光的像素，然后不停的做down sample并存在rt里，到达一定次数后（由参数控制），再一步步up scale回去，在这个过程中会将之前的rt加入，一步步up sample回到原来</p>
<h3 id="HDR和Tone-Mapping">HDR和Tone Mapping</h3>
<img src="/2024/10/19/TA-Graphics/image-20241009160222056.png" class="" title="image-20241009160222056">
<p>上面图片中，底下那张暗图是线性ToneMapping映射，可见效果极差！</p>
<img src="/2024/10/19/TA-Graphics/image-20241009160315449.png" class="" title="image-20241009160315449">
<h3 id="LUT——Look-Up-Table">LUT——Look Up Table</h3>
<p><strong>简单的理解</strong>：就是滤镜，通过LUT，你可以将一组RGB值输出为另一组RGB值，从而改变画面的曝光与色彩</p>
<p>和ToneMapping不同，<strong>LUT是在LDR之间做变化</strong>。 而ToneMapping是对HDR做变换的。</p>
<p>和ToneMapping不同，<strong>LUT是在LDR之间做变化</strong>。 而ToneMapping是对HDR做变换的。</p>
<img src="/2024/10/19/TA-Graphics/1622802574907-83768a94-990e-4ff4-959c-d0dcf48daada.webp" class="" title="image.png">
<h2 id="8-Flow-Map的实现">8.Flow Map的实现</h2>
<h3 id="什么是FlowMap">什么是FlowMap</h3>
<img src="/2024/10/19/TA-Graphics/image-20241011134945985.png" class="" title="image-20241011134945985">
<img src="/2024/10/19/TA-Graphics/image-20241011135933002.png" class="" title="image-20241011135933002">
<p>flowmap向量场偏移uv后采样结果如下：</p>
<img src="/2024/10/19/TA-Graphics/image-20241011135946676.png" class="" title="image-20241011135946676">
<img src="/2024/10/19/TA-Graphics/image-20241011140035578.png" class="" title="image-20241011140035578">
<h3 id="FlowMap的Shader实现">FlowMap的Shader实现</h3>
<p>使用UV - time</p>
<p>为什么是相减？<br>
先来看看 uv+time 的情况(u,v) + (time,0) :模型上某个点: 随着time增加，采样到的像素越远<br>
视觉上可以形容为：更远距离的像素偏移向该点，视觉效果和我们直观认识到的运算法则是相反的,所以需要相减</p>
<p>uv偏移并没有改变顶点位置，只是采样到了更远的像素</p>
<p>我们需要更好的运动方向，正确的方法是从flowMap获取流动方向</p>
<p>颜色值范围是[0,1]的，而方向向量的范围都是[-1,1]，因此我们就需要使用映射手段（即乘以2，减去1）,这样才能从FlowMap获取我们的流向(之前推导mvp矩阵时也用过这个方法)</p>
<p>拿到Time还需要使用frac函数取其小数部分，以达到我们的周期循环效果<br>
但frac()函数有个问题，那就是周期的有断层 人们希望0.99循环 到1的断层去掉 这时候有个聪明人想到了加权平均</p>
 <img src="/2024/10/19/TA-Graphics/image-20241011142941906.png" class="" title="image-20241011142941906">
<p>用两条有周期有规律变换的线 蓝紫两线的加权不断变换使断层效果消失  x=0.5时蓝线权重1 紫线权重0 x=1时蓝线权重0紫线权重1</p>
<img src="/2024/10/19/TA-Graphics/image-20241011143009298.png" class="" title="image-20241011143009298">
<img src="/2024/10/19/TA-Graphics/image-20241011143047723.png" class="" title="image-20241011143047723">
<p>代码：</p>
<img src="/2024/10/19/TA-Graphics/image-20241011143113116.png" class="" title="image-20241011143113116">
<p>（片元着色器部分）</p>
<h3 id="FlowMap纹理的制作工具和方法">FlowMap纹理的制作工具和方法</h3>
<h4 id="Flowmap-painter">Flowmap painter</h4>
<img src="/2024/10/19/TA-Graphics/image-20241011143343681.png" class="" title="image-20241011143343681">
<img src="/2024/10/19/TA-Graphics/image-20241011143637554.png" class="" title="image-20241011143637554">
<h4 id="Houdini制作FlowMap——（未看）">Houdini制作FlowMap——（未看）</h4>
<p>待填坑…没学过Houdini</p>
<h2 id="9-GPU硬件架构">9.GPU硬件架构</h2>
<h3 id="写得很好的笔记——晓痕">写得很好的笔记——晓痕</h3>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/xiaohen-ecwjj/vegbg9/xzfv8x#tVP0A">GPU硬件架构笔记 (yuque.com)</a></p>
<h3 id="GPU是什么">GPU是什么</h3>
<p>GPU 全称是 Graphics Processing Unit 图形处理单元<br>
GPU是显卡最核心的部件，但我们经常把gpu和显卡混用</p>
<h3 id="GPU架构的关键发展历史">GPU架构的关键发展历史</h3>
<img src="/2024/10/19/TA-Graphics/image-20241011151108030.png" class="" title="image-20241011151108030">
<h3 id="GPU微观物理结构">GPU微观物理结构</h3>
<img src="/2024/10/19/TA-Graphics/image-20241011150911035.png" class="" title="image-20241011150911035">
<img src="/2024/10/19/TA-Graphics/image-20241011151012903.png" class="" title="image-20241011151012903">
<img src="/2024/10/19/TA-Graphics/image-20241011151022481.png" class="" title="image-20241011151022481">
<img src="/2024/10/19/TA-Graphics/image-20241011151033244.png" class="" title="image-20241011151033244">
<img src="/2024/10/19/TA-Graphics/image-20241011151201987.png" class="" title="image-20241011151201987">
<img src="/2024/10/19/TA-Graphics/image-20241011151217181.png" class="" title="image-20241011151217181">
<img src="/2024/10/19/TA-Graphics/image-20241011151339716.png" class="" title="image-20241011151339716">
<h3 id="GPU完整的渲染流程">GPU完整的渲染流程</h3>
<img src="/2024/10/19/TA-Graphics/image-20241012173029135.png" class="" title="image-20241012173029135">
<img src="/2024/10/19/TA-Graphics/image-20241012173039304.png" class="" title="image-20241012173039304">
<img src="/2024/10/19/TA-Graphics/image-20241012172450377.png" class="" title="image-20241012172450377">
<img src="/2024/10/19/TA-Graphics/image-20241012173051383.png" class="" title="image-20241012173051383">
<img src="/2024/10/19/TA-Graphics/image-20241012173059597.png" class="" title="image-20241012173059597">
<img src="/2024/10/19/TA-Graphics/image-20241012173109274.png" class="" title="image-20241012173109274">
<h3 id="Early-Z">Early-Z</h3>
<img src="/2024/10/19/TA-Graphics/image-20241012174041994.png" class="" title="image-20241012174041994">
<h3 id="GPU的优化技术">GPU的优化技术</h3>
<h4 id="SIMD">SIMD</h4>
<img src="/2024/10/19/TA-Graphics/image-20241012174301468.png" class="" title="image-20241012174301468">
<h4 id="SIMT">SIMT</h4>
<img src="/2024/10/19/TA-Graphics/image-20241012174352978.png" class="" title="image-20241012174352978">
<p>SIMT时，相当于每一个Core都是上面SIMD的for循环中的一次循环<br>
SIMD中跑完一遍完整的for循环得到的结果和SIMT中一步指令得到的结果相同</p>
<h4 id="co-issue">co-issue</h4>
<img src="/2024/10/19/TA-Graphics/image-20241012174705371.png" class="" title="image-20241012174705371">
<h3 id="GPU资源机制">GPU资源机制</h3>
<h4 id="GPU的内存架构">GPU的内存架构</h4>
<p>GPU和CPU类似，也有多级缓存结构：寄存器，L1缓存，L2缓存，GPU显存，系统显存<br>
速度从左到右依次变慢</p>
<img src="/2024/10/19/TA-Graphics/image-20241012175407210.png" class="" title="image-20241012175407210">
<p><strong>由此可见，shader直接访问寄存器，L1,L2缓存比较快，但访问纹理，常量缓存和全局内存非常慢，会造成很高的延迟</strong></p>
<img src="/2024/10/19/TA-Graphics/image-20241012175608180.png" class="" title="image-20241012175608180">
<h3 id="Shader运行在硬件层面的理解">Shader运行在硬件层面的理解</h3>
<img src="/2024/10/19/TA-Graphics/image-20241012180107336.png" class="" title="image-20241012180107336">
<img src="/2024/10/19/TA-Graphics/image-20241012180115983.png" class="" title="image-20241012180115983">
<img src="/2024/10/19/TA-Graphics/image-20241012180201577.png" class="" title="image-20241012180201577">
<img src="/2024/10/19/TA-Graphics/image-20241012180259372.png" class="" title="image-20241012180259372">
<h1>三. 进阶应用</h1>
<h2 id="1-深度测试和模板测试">1.深度测试和模板测试</h2>
<h3 id="1-模板测试-Stencil-Test">1.模板测试 Stencil Test</h3>
<h4 id="模板测试的初步理解和效果">模板测试的初步理解和效果</h4>
<img src="/2024/10/19/TA-Graphics/image-20241012132101352.png" class="" title="image-20241012132101352">
<p>左图为颜色缓冲区，中间为模板缓冲区，我们人为设置部分像素位置模板值为1<br>
最后我们之渲染模板值为1的像素，其他都为黑色，就得到了右图</p>
<p>一些模板测试可以实现的效果：</p>
<img src="/2024/10/19/TA-Graphics/1.gif" class="" width="1">
<img src="/2024/10/19/TA-Graphics/66e37096-4aef-4baf-b743-0cb37bfc2a93.gif" class="" title="66e37096-4aef-4baf-b743-0cb37bfc2a93">
<p>作者：MinionsArt<br>
连接：<a target="_blank" rel="noopener" href="https://www.patreon.com/posts/14832618">https://www.patreon.com/posts/14832618</a></p>
<h4 id="模板测试是什么">模板测试是什么</h4>
<h5 id="1-从渲染管线来看，经过片元着色器后的阶段">1.从渲染管线来看，经过片元着色器后的阶段</h5>
<img src="/2024/10/19/TA-Graphics/image-20241012132945418.png" class="" title="image-20241012132945418">
<p>Pixel Ownership Test：测试哪些像素是有使用权限的。比如unity操作界面中，你的整个编辑器中只有game和scene的窗口部分会渲染游戏画面，因为只有这部分屏幕区域的像素有使用权限</p>
<p>Scissor Test：可以对要渲染的像素部分进行自定义规则的裁剪，比如你设置只渲染左上角</p>
<p>Alpha Test：透明度测试，给定片元透明度加减某参数结构小于0时会被剔除</p>
<h5 id="2-从逻辑上理解">2.从逻辑上理解</h5>
<img src="/2024/10/19/TA-Graphics/image-20241012133539964.png" class="" title="image-20241012133539964">
<h5 id="3-从概念上理解">3.从概念上理解</h5>
<img src="/2024/10/19/TA-Graphics/image-20241012133717647.png" class="" title="image-20241012133717647">
<h4 id="Unity-Shader中使用模板测试">Unity Shader中使用模板测试</h4>
<img src="/2024/10/19/TA-Graphics/image-20241012133853785.png" class="" title="image-20241012133853785">
<p>ZFail——模板测试通过但是深度测试未通过时执行什么操作</p>
<img src="/2024/10/19/TA-Graphics/image-20241012134042836.png" class="" title="image-20241012134042836">
<p>左边 是当前的Ref参考值<br>
右边 是当前模板buffer中存储的值</p>
<img src="/2024/10/19/TA-Graphics/image-20241012134119678.png" class="" title="image-20241012134119678">
<p>更新值就是stencilOperation</p>
<p><strong>渲染顺序：先渲染正常场景中的物体，再渲染写入模板值的Mask面，最后渲染模板测试中要部分渲染部分剔除的物体</strong></p>
<p>模板测试总结：</p>
<img src="/2024/10/19/TA-Graphics/image-20241012143027125.png" class="" title="image-20241012143027125">
<h4 id="模板测试扩展">模板测试扩展</h4>
<img src="/2024/10/19/TA-Graphics/image-20241012143101440.png" class="" title="image-20241012143101440">
<h4 id="模板测试Demo">模板测试Demo</h4>
<p>请见他人笔记<br>
<a target="_blank" rel="noopener" href="https://www.yuque.com/zohar-jpfbj/tiacmz/nw0g0g?#xNtdk">图形 3.1 深度与模板测试 (yuque.com)</a></p>
<h3 id="2-深度测试-Z-Test">2.深度测试 Z Test</h3>
<h4 id="深度测试是什么">深度测试是什么</h4>
<h5 id="1-从逻辑上理解">1.从逻辑上理解</h5>
<img src="/2024/10/19/TA-Graphics/image-20241012151344340.png" class="" title="image-20241012151344340">
<h5 id="2-从概念上理解">2.从概念上理解</h5>
<p>深度测试，就是针对当前对象在屏幕上（准确来讲是framebuffer中）所对应的像素点，将该对象该片元的深度值与当前该片元对应的像素点存储的深度值进行比较，如果通过了，本对象在该像素点才会将颜色写入该像素点的颜色缓冲区，否则不会写入颜色缓冲区</p>
<h5 id="2-从渲染的发展历史理解">2.从渲染的发展历史理解</h5>
<img src="/2024/10/19/TA-Graphics/image-20241012151751736.png" class="" title="image-20241012151751736">
<h4 id="深度缓冲区-Z-Buffer">深度缓冲区 Z-Buffer</h4>
<img src="/2024/10/19/TA-Graphics/image-20241012151957801.png" class="" title="image-20241012151957801">
<h4 id="Z-Write">Z Write</h4>
<img src="/2024/10/19/TA-Graphics/image-20241012152135243.png" class="" title="image-20241012152135243">
<h4 id="Z-Test的比较函数">Z Test的比较函数</h4>
<img src="/2024/10/19/TA-Graphics/image-20241012152241055.png" class="" title="image-20241012152241055">
<h4 id="渲染队列——Unity中">渲染队列——Unity中</h4>
<img src="/2024/10/19/TA-Graphics/image-20241012152535113.png" class="" title="image-20241012152535113">
<h4 id="简述Early-Z技术">简述Early-Z技术</h4>
<img src="/2024/10/19/TA-Graphics/image-20241012152854446.png" class="" title="image-20241012152854446">
<p>因为Z Test是在片元着色器之后进行的，会有大量浪费！</p>
<p>Early-Z就是Z-Cull 进行初步的遮挡剔除<br>
Z Test就是Z-Check 确保最终遮挡关系正确</p>
<p>Early-Z的具体技术讲解在后续内容</p>
<h4 id="Z-Buffer中的深度值为什么是非线性的？">Z-Buffer中的深度值为什么是非线性的？</h4>
<p><strong>正确的投影特性的非线性深度方程是和1/z成正比的，<strong>这样基本上做的是在</strong>Z很近的时候是高精度和Z很远的时候是底精度</strong>。这样就是模拟了人眼观察，<strong>近处的物体很清晰，而远处的物体很模糊。</strong></p>
<img src="/2024/10/19/TA-Graphics/image-20241012154353511.png" class="" title="image-20241012154353511">
<p>参考LearnOpenGL-深度测试章节</p>
<h4 id="深度冲突">深度冲突</h4>
<img src="/2024/10/19/TA-Graphics/image-20241012154837458.png" class="" title="image-20241012154837458">
<p>两个平面或三角形很<strong>紧密相互平行，深度缓冲区不具有足够的精度</strong>以至于无法得到哪一个靠前。导致了着两个形状<strong>不断切换顺序出现怪异问题</strong>。这被称为<strong>深度冲突（Z-fighting）</strong>，因为它看上去像形状争夺顶靠前的位置。</p>
<p>解决方法</p>
<ul>
<li>让物体之间不要离得太近。</li>
<li>尽可能把近平面设置得远一些。</li>
<li>放弃一部分性能来获得更高精度的深度值，把默认的24位深度缓冲改成32位。</li>
</ul>
<h4 id="深度测试Demo">深度测试Demo</h4>
<p>请见他人笔记<br>
<a target="_blank" rel="noopener" href="https://www.yuque.com/zohar-jpfbj/tiacmz/nw0g0g?#xNtdk">图形 3.1 深度与模板测试 (yuque.com)</a></p>
<p>注意：Unity中比如一个shader有两个Pass，其中一个Pass的渲染队列是Transparent，一个是Opaque<br>
实际上使用这个shader的材质的物体会取二者中小的那个，也就是统一变成了Opaque，也就是Geometry渲染队列<br>
然后Pass渲染按照代码中顺序执行，先执行上面的</p>
<h4 id="深度测试扩展">深度测试扩展</h4>
<img src="/2024/10/19/TA-Graphics/image-20241012163254853.png" class="" title="image-20241012163254853">
<h2 id="2-混合模式及剔除">2.混合模式及剔除</h2>
<h3 id="什么是混合模式">什么是混合模式</h3>
<p>混合（Blend）就是把两种颜色混在一起，具体就是把某一像素位置原来存储的原色和当前即将要画上去的颜色通过某种方式或算法混在一起</p>
<p>最终颜色 = Shader计算后的颜色值 * 源因子（SrcFactor）+ 累积颜色 * 目标因子（DstFactor）<br>
累积颜色：GBuffer中存储的颜色值（可以理解为当前物体后面及背景在该像素的颜色）</p>
<h3 id="混合模式有哪些呢">混合模式有哪些呢</h3>
<h4 id="PS中的混合模式">PS中的混合模式</h4>
<img src="/2024/10/19/TA-Graphics/image-20241013154614716.png" class="" title="image-20241013154614716">
<h4 id="ShaderLab中的混合模式">ShaderLab中的混合模式</h4>
<p>1.如果颜色某一分量超过1，会被自动截取到1，无需考虑越界问题<br>
2.语法</p>
<img src="/2024/10/19/TA-Graphics/image-20241013154836300.png" class="" title="image-20241013154836300">
<h4 id="Blend和Blend-Op">Blend和Blend Op</h4>
<img src="/2024/10/19/TA-Graphics/image-20241013155202984.png" class="" title="image-20241013155202984">
<img src="/2024/10/19/TA-Graphics/image-20241013155218265.png" class="" title="image-20241013155218265">
<h5 id="常见的Blend命令">常见的Blend命令</h5>
<img src="/2024/10/19/TA-Graphics/image-20241013155412068.png" class="" title="image-20241013155412068">
<h5 id="BlendOp">BlendOp</h5>
<p>决定Blend操作源颜色值和目标颜色值之间如何混合<br>
是Add 加，还是Sub减？<br>
还有很多很多，可以去查API，如果只写了Blend但是没写BlendOp，默认BlendOp为Add</p>
<img src="/2024/10/19/TA-Graphics/image-20241013155642506.png" class="" title="image-20241013155642506">
<h5 id="Unity里Blend枚举变量序列化语法">Unity里Blend枚举变量序列化语法</h5>
<img src="/2024/10/19/TA-Graphics/image-20241013160040055.png" class="" title="image-20241013160040055">
<h5 id="各种混合效果实例">各种混合效果实例</h5>
<h6 id="Normal正常">Normal正常</h6>
<img src="/2024/10/19/TA-Graphics/image-20241013160807555.png" class="" title="image-20241013160807555">
<h6 id="Darken变暗">Darken变暗</h6>
<img src="/2024/10/19/TA-Graphics/image-20241013160839387.png" class="" title="image-20241013160839387">
<h6 id="Multipy正片叠底">Multipy正片叠底</h6>
<img src="/2024/10/19/TA-Graphics/image-20241013161005123.png" class="" title="image-20241013161005123">
<h6 id="Screen滤色">Screen滤色</h6>
<img src="/2024/10/19/TA-Graphics/image-20241013161051286.png" class="" title="image-20241013161051286">
<h6 id="Lighten变亮">Lighten变亮</h6>
<img src="/2024/10/19/TA-Graphics/image-20241013161316338.png" class="" title="image-20241013161316338">
<h6 id="LinearDodge线性减淡">LinearDodge线性减淡</h6>
<img src="/2024/10/19/TA-Graphics/image-20241013161354920.png" class="" title="image-20241013161354920">
<h6 id="ColorBurn颜色加深">ColorBurn颜色加深</h6>
<img src="/2024/10/19/TA-Graphics/image-20241013161424745.png" class="" title="image-20241013161424745">
<h3 id="剔除">剔除</h3>
<p><strong>法线剔除</strong>：也被称为背面消隐。根据法线朝向判断哪个面被剔除，可以用来控制是否双面渲染。<br>
语法：Cull Off/Front/Back</p>
<p><strong>面裁剪</strong>：clip()函数，将输入参数小于0的对应的片元在片元着色器直接丢弃（discard），常用于制作溶解，裁剪效果<br>
语法：clip(); 默认会裁切小于0的部分</p>
<h2 id="3-曲面细分着色器与几何着色器">3.曲面细分着色器与几何着色器</h2>
<img src="/2024/10/19/TA-Graphics/image-20241013164437677.png" class="" title="image-20241013164437677">
<img src="/2024/10/19/TA-Graphics/image-20241013164450177.png" class="" title="image-20241013164450177">
<h3 id="渲染管线中的顺序">渲染管线中的顺序</h3>
<img src="/2024/10/19/TA-Graphics/image-20241013170557166.png" class="" title="image-20241013170557166">
<p>Tess——曲面细分着色器<br>
又分为Hull Shader——细分控制着色器<br>
Tessellation Primitive Generator——细分图元生成器，硬件完成<br>
Domain Shder——细分计算着色器</p>
<h3 id="曲面细分着色器-Tessellation-Shader">曲面细分着色器 Tessellation Shader</h3>
<h4 id="TESS的输入和输出">TESS的输入和输出</h4>
<img src="/2024/10/19/TA-Graphics/image-20241013170848877.png" class="" title="image-20241013170848877">
<h4 id="TESS的渲染流程">TESS的渲染流程</h4>
<img src="/2024/10/19/TA-Graphics/image-20241013171012562.png" class="" title="image-20241013171012562">
<p>重心空间就是以重心为原点的坐标空间</p>
<h4 id="Hull-Shader部分">Hull Shader部分</h4>
<p><strong>1.Tessellation Factor 参数</strong><br>
决定将一条边分成几个部分，有如下三种切分的方法（算法）</p>
<img src="/2024/10/19/TA-Graphics/1634788323314-d0eaed26-de33-4130-9b95-108de66ea235.gif" class="" title="img">
<p>区别：<br>
equal_Spacing:将一条边等分，Subdivide参数是多少，就是多少等分<br>
fractional_even_Spacing:最小值是2，Subdivide参数向上取最近的偶数，将周长分为中间分段为等长的Subdivide - 2段，最左和最右两段为剩下的长度分出来的部分（因为Subdivide可取小数，所以这两段长度和小数有关系），目的是让细分更平滑<br>
fractional_odd_Spacing:最小值为1，Subdivide参数向上取最近的奇数，将周长分为Subdivide - 2的等长的部分，以及两端不等长的部分，目的是让细分更平滑</p>
<p><strong>2.Inner Tessellation Factor 参数</strong></p>
<p>内部细分因素，当该参数为3时，无论上面的Tessellation Factor怎样去进行切分的，我们把三角形切分为三等分，然后分别找最近的两个切分的点，做其延长线，其焦点便是在新内部三角形的一个点；<br>
（概括下就是取边上点的垂线的延长线做交点，直至最后无交点或者交于中心一点）</p>
<img src="/2024/10/19/TA-Graphics/image-20241013172056143.png" class="" title="image-20241013172056143">
<h4 id="曲面细分着色器的Demo">曲面细分着色器的Demo</h4>
<h5 id="1-细分一个Quad">1.细分一个Quad</h5>
<p>着重观察Hull Shader中参数对细分的影响</p>
<img src="/2024/10/19/TA-Graphics/1638007452399-4537d5f3-8d73-40cc-a9f7-022696ec61d6.gif" class="" title="img">
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//曲面细分Demo1</span></span><br><span class="line">Shader &quot;Unlit/TessShader&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _TessellationUniform (&quot;TessellationUniform&quot;, Range(<span class="number">1</span>, <span class="number">64</span>)) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="comment">// 定义两个函数 hull domain</span></span><br><span class="line">            <span class="meta">#pragma hull hullProgram</span></span><br><span class="line">            <span class="meta">#pragma domain ds</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#pragma vertex tessvert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            <span class="comment">// 引入曲面细分的头文件</span></span><br><span class="line">            <span class="meta">#include &quot;Tessellation.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#pragma target 5.0</span></span><br><span class="line"></span><br><span class="line">            struct VertexInput</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct VertexOutput</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 这个函数应用在domain函数钟，用来空间转换的函数</span></span><br><span class="line">            VertexOutput vert (VertexInput v)</span><br><span class="line">            &#123;</span><br><span class="line">                VertexOutput o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.uv;</span><br><span class="line">                o.normal = v.normal;</span><br><span class="line">                o.tangent = v.tangent;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 有些硬件不支持曲面细分着色器，定义了该宏就能够在不支持的硬件上不会变粉，也不会报错</span></span><br><span class="line">            <span class="meta">#ifdef UNITY_CAN_COMPILE_TESSELLATION</span></span><br><span class="line">                <span class="comment">// 顶点着色器结构的定义</span></span><br><span class="line">                struct TessVertex</span><br><span class="line">                &#123;</span><br><span class="line">                    float4 vertex : INTERNALTESSPOS;</span><br><span class="line">                    float3 normal : NORMAL;</span><br><span class="line">                    float4 tangent : TANGENT;</span><br><span class="line">                    float2 uv : TEXCOORD0;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                struct OutputPatchConstant</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 不同的图元，该结构会有所不同</span></span><br><span class="line">                    <span class="comment">// 该部分用于Hull Shader里面</span></span><br><span class="line">                    <span class="comment">// 定义patch的属性</span></span><br><span class="line">                    <span class="comment">// Tessellation Factor和Inner Tessellation Factor</span></span><br><span class="line">                    <span class="type">float</span> edge[<span class="number">3</span>] : SV_TESSFACTOR;</span><br><span class="line">                    <span class="type">float</span> inside  : SV_INSIDETESSFACTOR;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 顶点着色器函数</span></span><br><span class="line">                TessVertex tessvert(VertexInput v)</span><br><span class="line">                &#123;</span><br><span class="line">                    TessVertex o;</span><br><span class="line">                    o.vertex = v.vertex;</span><br><span class="line">                    o.normal = v.normal;</span><br><span class="line">                    o.tangent = v.tangent;</span><br><span class="line">                    o.uv = v.uv;</span><br><span class="line">                    <span class="keyword">return</span> o;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 定义曲面细分的参数</span></span><br><span class="line">                <span class="type">float</span> _TessellationUniform;</span><br><span class="line">                OutputPatchConstant hsconst (InputPatch&lt;TessVertex, <span class="number">3</span>&gt; <span class="keyword">patch</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    OutputPatchConstant o;</span><br><span class="line">                    o.edge[<span class="number">0</span>] = _TessellationUniform;</span><br><span class="line">                    o.edge[<span class="number">1</span>] = _TessellationUniform;</span><br><span class="line">                    o.edge[<span class="number">2</span>] = _TessellationUniform;</span><br><span class="line">                    o.inside = _TessellationUniform;</span><br><span class="line">                    <span class="keyword">return</span> o;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                [UNITY_domain(&quot;tri&quot;)] <span class="comment">// 确定图元，quad，triangle等</span></span><br><span class="line">                [UNITY_partitioning(&quot;fractional_odd&quot;)] <span class="comment">// 拆分edge的规则， equal_spacing,fractional_odd,fractional_even</span></span><br><span class="line">                [UNITY_outputtopology(&quot;triangle_cw&quot;)]</span><br><span class="line">                [UNITY_patchconstantfunc(&quot;hsconst&quot;)] <span class="comment">// 一个patch一共三个点，但是这三个点都共用这个函数</span></span><br><span class="line">                [UNITY_outputcontrolpoints(<span class="number">3</span>)] <span class="comment">// 不同的图元对应不同的控制点</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 定义hullshaderV函数</span></span><br><span class="line">                TessVertex hullProgram (InputPatch&lt;TessVertex, <span class="number">3</span>&gt; <span class="keyword">patch</span>,<span class="type">uint</span> id : SV_OutputControlPointID)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">patch</span>[id];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                [UNITY_domain(&quot;tri&quot;)] <span class="comment">// 同样需要定义图元</span></span><br><span class="line">                <span class="comment">// 进行空间转换，将切线空间下的顶点转换至模型空间    bary：重心空间下的顶点位置信息</span></span><br><span class="line">                VertexOutput ds (OutputPatchConstant tessFactors, <span class="keyword">const</span> OutputPatch&lt;TessVertex, <span class="number">3</span>&gt; <span class="keyword">patch</span>, float3 bary : SV_DOMAINLOCATION)</span><br><span class="line">                &#123;</span><br><span class="line">                    VertexInput v;</span><br><span class="line">                    v.vertex = <span class="keyword">patch</span>[<span class="number">0</span>].vertex * bary.x + <span class="keyword">patch</span>[<span class="number">1</span>].vertex * bary.y + <span class="keyword">patch</span>[<span class="number">2</span>].vertex * bary.z;</span><br><span class="line">                    v.normal = <span class="keyword">patch</span>[<span class="number">0</span>].normal * bary.x + <span class="keyword">patch</span>[<span class="number">1</span>].normal * bary.y + <span class="keyword">patch</span>[<span class="number">2</span>].normal * bary.z;</span><br><span class="line">                    v.tangent = <span class="keyword">patch</span>[<span class="number">0</span>].tangent * bary.x + <span class="keyword">patch</span>[<span class="number">1</span>].tangent * bary.y + <span class="keyword">patch</span>[<span class="number">2</span>].tangent * bary.z;</span><br><span class="line">                    v.uv = <span class="keyword">patch</span>[<span class="number">0</span>].uv * bary.x + <span class="keyword">patch</span>[<span class="number">1</span>].uv * bary.y + <span class="keyword">patch</span>[<span class="number">2</span>].uv * bary.z;</span><br><span class="line">                    VertexOutput o = vert(v);</span><br><span class="line">                    <span class="keyword">return</span> o;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">            fixed4 frag (VertexOutput i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> float4(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="2-细分着色器配合displacement贴图">2.细分着色器配合displacement贴图</h5>
<img src="/2024/10/19/TA-Graphics/1638013890141-1628d159-3029-401a-95bf-6f8409df6048.gif" class="" title="img">
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//曲面细分Demo2：与置换贴图结合使用</span></span><br><span class="line">Shader &quot;Unlit/Tess_Diss_Shader&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;MainTex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _DisplacementMap (&quot;DisplacementMap&quot;, <span class="number">2</span>D) = &quot;gray&quot; &#123;&#125;</span><br><span class="line">        _DisplacementStrength (&quot;DisplacementStrength&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">        _Smoothness (&quot;Smoothness&quot;, Range(<span class="number">0</span>, <span class="number">5</span>)) = <span class="number">0.5</span></span><br><span class="line">        _TessellationUniform (&quot;TessellationUniform&quot;, Range(<span class="number">1</span>, <span class="number">64</span>)) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="comment">// 定义两个函数 hull domain</span></span><br><span class="line">            <span class="meta">#pragma hull hullProgram</span></span><br><span class="line">            <span class="meta">#pragma domain ds</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#pragma vertex tessvert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="comment">// 引入曲面细分的头文件</span></span><br><span class="line">            <span class="meta">#include &quot;Tessellation.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#pragma target 5.0</span></span><br><span class="line"></span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;   float4 _MainTex_ST;</span><br><span class="line">            <span class="type">sampler2D</span> _DisplacementMap;   float4 _DisplacementMap_ST;</span><br><span class="line"></span><br><span class="line">            <span class="type">float</span> _DisplacementStrength;</span><br><span class="line">            <span class="type">float</span> _Smoothness;</span><br><span class="line">            <span class="type">float</span> _TessellationUniform;</span><br><span class="line"></span><br><span class="line">            struct VertexInput</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct VertexOutput</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 worldPos : TEXCOORD1;</span><br><span class="line">                half3 tspace0 : TEXCOORD2;</span><br><span class="line">                half3 tspace1 : TEXCOORD3;</span><br><span class="line">                half3 tspace2 : TEXCOORD4;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 这个函数应用在domain函数钟，用来空间转换的函数</span></span><br><span class="line">            VertexOutput vert (VertexInput v)</span><br><span class="line">            &#123;</span><br><span class="line">                VertexOutput o;</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">                <span class="comment">// Displacement   由于并不是在Fragment shader中读取图片，GPU无法获取mipmap信息，</span></span><br><span class="line">                <span class="comment">// 因此需要使用tex2Dlod来读取图片，使用z坐标作为mipmap的level，这里取了0</span></span><br><span class="line">                <span class="type">float</span> Displacement = tex2Dlod(_DisplacementMap, float4(o.uv.xy, <span class="number">0.0</span>, <span class="number">0.0</span>)).g;</span><br><span class="line">                Displacement = (Displacement - <span class="number">0.5</span>) * _DisplacementStrength;</span><br><span class="line">                v.normal = <span class="built_in">normalize</span>(v.normal);</span><br><span class="line">                v.vertex.xyz += v.normal * Displacement;</span><br><span class="line"></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 计算切线空间转换矩阵</span></span><br><span class="line">                half3 vNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                half3 vTangent = UnityObjectToWorldDir(v.tangent.xyz);</span><br><span class="line">                half tangentSign = v.tangent.w * unity_WorldTransformParams.w;</span><br><span class="line">                half3 vBitangent = <span class="built_in">cross</span>(vNormal, vTangent) * tangentSign;</span><br><span class="line">                <span class="comment">// output the tangent space matrix</span></span><br><span class="line">                o.tspace0 = half3(vTangent.x, vBitangent.x, vNormal.x);</span><br><span class="line">                o.tspace1 = half3(vTangent.y, vBitangent.y, vNormal.y);</span><br><span class="line">                o.tspace2 = half3(vTangent.z, vBitangent.z, vNormal.z);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 有些硬件不支持曲面细分着色器，定义了该宏就能够在不支持的硬件上不会变粉，也不会报错</span></span><br><span class="line">            <span class="meta">#ifdef UNITY_CAN_COMPILE_TESSELLATION</span></span><br><span class="line">                <span class="comment">// 顶点着色器结构的定义</span></span><br><span class="line">                struct TessVertex</span><br><span class="line">                &#123;</span><br><span class="line">                    float4 vertex : INTERNALTESSPOS;</span><br><span class="line">                    float3 normal : NORMAL;</span><br><span class="line">                    float4 tangent : TANGENT;</span><br><span class="line">                    float2 uv : TEXCOORD0;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                struct OutputPatchConstant</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 不同的图元，该结构会有所不同</span></span><br><span class="line">                    <span class="comment">// 该部分用于Hull Shader里面</span></span><br><span class="line">                    <span class="comment">// 定义patch的属性</span></span><br><span class="line">                    <span class="comment">// Tessellation Factor和Inner Tessellation Factor</span></span><br><span class="line">                    <span class="type">float</span> edge[<span class="number">3</span>] : SV_TESSFACTOR;</span><br><span class="line">                    <span class="type">float</span> inside  : SV_INSIDETESSFACTOR;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 顶点着色器函数</span></span><br><span class="line">                TessVertex tessvert(VertexInput v)</span><br><span class="line">                &#123;</span><br><span class="line">                    TessVertex o;</span><br><span class="line">                    o.vertex = v.vertex;</span><br><span class="line">                    o.normal = v.normal;</span><br><span class="line">                    o.tangent = v.tangent;</span><br><span class="line">                    o.uv = v.uv;</span><br><span class="line">                    <span class="keyword">return</span> o;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 定义曲面细分的参数</span></span><br><span class="line">                <span class="comment">//float _TessellationUniform;</span></span><br><span class="line">                OutputPatchConstant hsconst (InputPatch&lt;TessVertex, <span class="number">3</span>&gt; <span class="keyword">patch</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    OutputPatchConstant o;</span><br><span class="line">                    o.edge[<span class="number">0</span>] = _TessellationUniform;</span><br><span class="line">                    o.edge[<span class="number">1</span>] = _TessellationUniform;</span><br><span class="line">                    o.edge[<span class="number">2</span>] = _TessellationUniform;</span><br><span class="line">                    o.inside = _TessellationUniform;</span><br><span class="line">                    <span class="keyword">return</span> o;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                [UNITY_domain(&quot;tri&quot;)] <span class="comment">// 确定图元，quad，triangle等</span></span><br><span class="line">                [UNITY_partitioning(&quot;fractional_odd&quot;)] <span class="comment">// 拆分edge的规则， equal_spacing,fractional_odd,fractional_even</span></span><br><span class="line">                [UNITY_outputtopology(&quot;triangle_cw&quot;)]</span><br><span class="line">                [UNITY_patchconstantfunc(&quot;hsconst&quot;)] <span class="comment">// 一个patch一共三个点，但是这三个点都共用这个函数</span></span><br><span class="line">                [UNITY_outputcontrolpoints(<span class="number">3</span>)] <span class="comment">// 不同的图元对应不同的控制点</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 定义hullshaderV函数</span></span><br><span class="line">                TessVertex hullProgram (InputPatch&lt;TessVertex, <span class="number">3</span>&gt; <span class="keyword">patch</span>,<span class="type">uint</span> id : SV_OutputControlPointID)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">patch</span>[id];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                [UNITY_domain(&quot;tri&quot;)] <span class="comment">// 同样需要定义图元</span></span><br><span class="line">                <span class="comment">// 进行空间转换，将切线空间下的顶点转换至模型空间    bary：重心空间下的顶点位置信息</span></span><br><span class="line">                VertexOutput ds (OutputPatchConstant tessFactors, <span class="keyword">const</span> OutputPatch&lt;TessVertex, <span class="number">3</span>&gt; <span class="keyword">patch</span>, float3 bary : SV_DOMAINLOCATION)</span><br><span class="line">                &#123;</span><br><span class="line">                    VertexInput v;</span><br><span class="line">                    v.vertex = <span class="keyword">patch</span>[<span class="number">0</span>].vertex * bary.x + <span class="keyword">patch</span>[<span class="number">1</span>].vertex * bary.y + <span class="keyword">patch</span>[<span class="number">2</span>].vertex * bary.z;</span><br><span class="line">                    v.normal = <span class="keyword">patch</span>[<span class="number">0</span>].normal * bary.x + <span class="keyword">patch</span>[<span class="number">1</span>].normal * bary.y + <span class="keyword">patch</span>[<span class="number">2</span>].normal * bary.z;</span><br><span class="line">                    v.tangent = <span class="keyword">patch</span>[<span class="number">0</span>].tangent * bary.x + <span class="keyword">patch</span>[<span class="number">1</span>].tangent * bary.y + <span class="keyword">patch</span>[<span class="number">2</span>].tangent * bary.z;</span><br><span class="line">                    v.uv = <span class="keyword">patch</span>[<span class="number">0</span>].uv * bary.x + <span class="keyword">patch</span>[<span class="number">1</span>].uv * bary.y + <span class="keyword">patch</span>[<span class="number">2</span>].uv * bary.z;</span><br><span class="line">                    VertexOutput o = vert(v);</span><br><span class="line">                    <span class="keyword">return</span> o;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">            fixed4 frag (VertexOutput i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                float3 lightDir = _WorldSpaceLightPos0.xyz;</span><br><span class="line">                float3 tnormal = UnpackNormal(tex2D(_DisplacementMap, i.uv));</span><br><span class="line">                half3 worldNormal;</span><br><span class="line">                worldNormal.x = <span class="built_in">dot</span>(i.tspace0, tnormal);</span><br><span class="line">                worldNormal.y = <span class="built_in">dot</span>(i.tspace1, tnormal);</span><br><span class="line">                worldNormal.z = <span class="built_in">dot</span>(i.tspace2, tnormal);</span><br><span class="line">                float3 albedo = tex2D(_MainTex, i.uv).rgb;</span><br><span class="line">                float3 lightColor = _LightColor0.rgb;</span><br><span class="line">                float3 diffuse = albedo * lightColor * DotClamped(lightDir, worldNormal);</span><br><span class="line">                float3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">                float3 halfDir = <span class="built_in">normalize</span>(lightDir + viewDir);</span><br><span class="line">                float3 specular = albedo * <span class="built_in">pow</span>(DotClamped(halfDir, worldNormal), _Smoothness * <span class="number">100</span>);</span><br><span class="line">                float3 result = diffuse + specular;</span><br><span class="line">                <span class="keyword">return</span> float4(result, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="几何着色器-Geometry-Shader">几何着色器 Geometry Shader</h3>
<h4 id="GS的输入和输出">GS的输入和输出</h4>
<p>输入：图元Primitive（三角形，矩形，线，点 等）根据图元的不同，shader中会传入对应不同数量的顶点</p>
<p>输出：图元Primitive，一个或多个，需要自己从顶点构建，顺序很重要，同时需要定义最大输出的顶点数</p>
<h4 id="几何着色器的Demo">几何着色器的Demo</h4>
<h5 id="1-三角形生成简单的草">1.三角形生成简单的草</h5>
<img src="/2024/10/19/TA-Graphics/1638019002280-a0bb6f3f-8988-4d9e-bae7-20270e11c7be.gif" class="" title="img">
<img src="/2024/10/19/TA-Graphics/1638019017707-34421798-f741-4ecb-be4f-566622e7fda4.gif" class="" title="img">
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unlit/Grass&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _TopColor (&quot;上部颜色&quot;, Color) = (<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>)</span><br><span class="line">        _BottomColor (&quot;下部颜色&quot;, Color) = (<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>)</span><br><span class="line">        _TranslucentGain (&quot;半透明度&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">        _BladeWidth (&quot;基础宽度&quot;, <span class="type">float</span>) = <span class="number">0.05</span></span><br><span class="line">        _BladeWidthRandom (&quot;随机宽度系数&quot;, <span class="type">float</span>) = <span class="number">0.02</span></span><br><span class="line">        _BladeHeight (&quot;基础高度&quot;, <span class="type">float</span>) = <span class="number">0.5</span></span><br><span class="line">        _BladeHeightRandom (&quot;随机高度系数&quot;, <span class="type">float</span>) = <span class="number">0.3</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line">        cull off</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            <span class="meta">#pragma geometry geo  // 定义一个几何着色器</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">uniform</span> float4 _TopColor;</span><br><span class="line">            <span class="keyword">uniform</span> float4 _BottomColor;</span><br><span class="line">            <span class="keyword">uniform</span> <span class="type">float</span> _TranslucentGain;</span><br><span class="line">            <span class="keyword">uniform</span> <span class="type">float</span> _BladeWidth;</span><br><span class="line">            <span class="keyword">uniform</span> <span class="type">float</span> _BladeWidthRandom;</span><br><span class="line">            <span class="keyword">uniform</span> <span class="type">float</span> _BladeHeight;</span><br><span class="line">            <span class="keyword">uniform</span> <span class="type">float</span> _BladeHeightRandom;</span><br><span class="line"></span><br><span class="line">            <span class="type">float</span> rand(float3 co)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">float</span> f = frac(<span class="built_in">sin</span>(<span class="built_in">dot</span>(co.xyz, float3(<span class="number">12.9898</span>, <span class="number">78.233</span>, <span class="number">53.539</span>))) * <span class="number">43758.5453</span>);</span><br><span class="line">                <span class="keyword">return</span> f;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            float3x3 AngleAxis3x3(<span class="type">float</span> angle, float3 axis)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">float</span> c, s;</span><br><span class="line">                sincos(angle, s, c);</span><br><span class="line"></span><br><span class="line">                <span class="type">float</span> t = <span class="number">1</span> - c;</span><br><span class="line">                <span class="type">float</span> x = axis.x;</span><br><span class="line">                <span class="type">float</span> y = axis.y;</span><br><span class="line">                <span class="type">float</span> z = axis.z;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> float3x3(</span><br><span class="line">                    t * x * x + c, t * x * y - s *z, t * x * z + s * y,</span><br><span class="line">					t * x * x + s * z, t * y * y + c, t * y * z - s * x,</span><br><span class="line">					t * x * z - s * y, t * y * z + s * x, t * z * z + c</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            struct vertexInput</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct vertexOutput</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            vertexOutput vert (vertexInput v)</span><br><span class="line">            &#123;</span><br><span class="line">                vertexOutput o;</span><br><span class="line">                o.vertex = v.vertex;</span><br><span class="line">                o.normal = v.normal;</span><br><span class="line">                o.tangent = v.tangent;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            struct geometryOutput</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            geometryOutput CreateGeoOutput(float3 pos, float2 uv)</span><br><span class="line">            &#123;</span><br><span class="line">                geometryOutput o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(pos);</span><br><span class="line">                o.uv = uv;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            [maxvertexcount(<span class="number">3</span>)] <span class="comment">// 定义最多顶点数</span></span><br><span class="line">            <span class="type">void</span> geo(triangle vertexOutput IN[<span class="number">3</span>] : SV_POSITION, <span class="keyword">inout</span> TriangleStream&lt;geometryOutput&gt; triStream)</span><br><span class="line">            &#123;</span><br><span class="line">                float3 pos = IN[<span class="number">0</span>].vertex;</span><br><span class="line">                float3 vNormal = IN[<span class="number">0</span>].normal;</span><br><span class="line">                float4 vTangent = IN[<span class="number">0</span>].tangent;</span><br><span class="line">                float3 vBinormal = <span class="built_in">cross</span>(vNormal, vTangent) * vTangent.w;</span><br><span class="line"></span><br><span class="line">                <span class="type">float</span> height = (rand(pos.xyz) * <span class="number">2</span> <span class="number">-1</span>) * _BladeHeightRandom + _BladeHeight;</span><br><span class="line">                <span class="type">float</span> width = (rand(pos.xyz) * <span class="number">2</span> - <span class="number">1</span>) * _BladeWidthRandom + _BladeWidth;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 构建矩阵 构建了TBN矩阵，并且于旋转矩阵相乘，获得转换矩阵</span></span><br><span class="line">                float3x3 facingRotationMatrix = AngleAxis3x3(rand(pos) * UNITY_TWO_PI, float3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">                float3x3 TBN = float3x3(</span><br><span class="line">                    vTangent.x, vBinormal.x, vNormal.x,</span><br><span class="line">				    vTangent.y, vBinormal.y, vNormal.y,</span><br><span class="line">				    vTangent.z, vBinormal.z, vNormal.z</span><br><span class="line">                );</span><br><span class="line">                float3x3 transformationMat = mul(TBN, facingRotationMatrix);</span><br><span class="line">                geometryOutput o;</span><br><span class="line">                <span class="comment">//&quot;TriangleStream&quot;类似用来装配三角形的工具,用来输出图元</span></span><br><span class="line">			    triStream.Append(CreateGeoOutput(pos+mul(transformationMat,float3(width,<span class="number">0</span>,<span class="number">0</span>)),float2(<span class="number">0</span>,<span class="number">0</span>)));</span><br><span class="line">			    triStream.Append(CreateGeoOutput(pos+mul(transformationMat,float3(-width,<span class="number">0</span>,<span class="number">0</span>)),float2(<span class="number">1</span>,<span class="number">0</span>)));</span><br><span class="line">				triStream.Append(CreateGeoOutput(pos+mul(transformationMat,float3(<span class="number">0</span>,<span class="number">0</span>,height)),float2(<span class="number">0.5</span>,<span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (geometryOutput i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                fixed4 color = lerp(_BottomColor, _TopColor, i.uv.y);</span><br><span class="line">                <span class="keyword">return</span> color;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="二者搭配实现一个完整的草地（重点）">二者搭配实现一个完整的草地（重点）</h3>
<img src="/2024/10/19/TA-Graphics/1638036523711-77612574-de58-45cf-9b9e-f5b617edfb35.gif" class="" title="wind2.gif">
<p><strong>完整教程链接：<a target="_blank" rel="noopener" href="https://roystan.net/articles/grass-shader">https://roystan.net/articles/grass-shader</a></strong></p>
<h1>四. 高级扩展</h1>
<h1>五. 物理世界</h1>
<h1>六. 非真实感渲染</h1>
<h1>七. 其他</h1>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://clouduooo.github.io">Clouduo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://clouduooo.github.io/2024/10/19/TA-Graphics/">https://clouduooo.github.io/2024/10/19/TA-Graphics/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://clouduooo.github.io" target="_blank">Clouduoの博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/Clouduo.PNG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/19/Clouduo-Demo/" title="Clouduo作品集"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Clouduo作品集</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/19/CS61C/" title="CS61C-笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CS61C-笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/Clouduo.PNG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Clouduo</div><div class="author-info__description">Clouduo很懒，并不想写任何描述</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Clouduooo" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://space.bilibili.com/36218679?spm_id_from=333.1007.0.0" target="_blank" title="Bilibili"><i class="fa-brands fa-bilibili"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">一. 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">2.1.</span> <span class="toc-text">1.渲染流水线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80"><span class="toc-number">2.2.</span> <span class="toc-text">2.数学基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BA%B9%E7%90%86%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.3.</span> <span class="toc-text">3.纹理介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%B9%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.3.1.</span> <span class="toc-text">纹理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%B9%E7%90%86%E7%AE%A1%E7%BA%BF"><span class="toc-number">2.3.2.</span> <span class="toc-text">纹理管线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%B9%E7%90%86%E9%87%87%E6%A0%B7%E8%AE%BE%E7%BD%AE"><span class="toc-number">2.3.3.</span> <span class="toc-text">纹理采样设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mipmap"><span class="toc-number">2.3.4.</span> <span class="toc-text">mipmap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mipmap%E7%9A%84%E7%94%9F%E6%88%90%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">mipmap的生成原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mipmap%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8%E6%97%B6%E9%87%87%E6%A0%B7level%E7%9A%84%E9%80%89%E6%8B%A9%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">mipmap具体使用时采样level的选择原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC"><span class="toc-number">2.3.4.3.</span> <span class="toc-text">三线性插值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mipmap%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-number">2.3.4.4.</span> <span class="toc-text">mipmap的缺陷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7%E8%BF%87%E6%BB%A4"><span class="toc-number">2.3.4.5.</span> <span class="toc-text">各向异性过滤</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A7%AF%E5%88%86%E5%9B%BESummed-Area-Table"><span class="toc-number">2.3.4.5.1.</span> <span class="toc-text">积分图Summed-Area Table</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%BA%A6%E6%9D%9F%E7%9A%84%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7%E8%BF%87%E6%BB%A4%E2%80%94%E2%80%94%E8%AE%A9%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E4%B9%9F%E5%87%A0%E4%B9%8E%E5%8F%AA%E6%98%AF%E5%A4%9A%E4%BA%861-3"><span class="toc-number">2.3.4.6.</span> <span class="toc-text">无约束的各向异性过滤——让内存占用也几乎只是多了1&#x2F;3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EWA%E8%BF%87%E6%BB%A4"><span class="toc-number">2.3.4.7.</span> <span class="toc-text">EWA过滤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%B9%E7%90%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96"><span class="toc-number">2.3.5.</span> <span class="toc-text">纹理相关的渲染优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU%E4%B8%8A%E7%9A%84%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E7%BA%B9%E7%90%86%E5%9B%BE%E9%9B%86-%E6%95%B0%E7%BB%84"><span class="toc-number">2.3.5.1.</span> <span class="toc-text">CPU上的优化——使用纹理图集&#x2F;数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GPU%E4%B8%8A%E7%9A%84%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E7%BA%B9%E7%90%86%E5%8E%8B%E7%BC%A9"><span class="toc-number">2.3.5.2.</span> <span class="toc-text">GPU上的优化——纹理压缩</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%B9%E7%90%86"><span class="toc-number">2.3.6.</span> <span class="toc-text">常见的纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CubeMap-%E7%AB%8B%E6%96%B9%E4%BD%93%E7%BA%B9%E7%90%86"><span class="toc-number">2.3.6.1.</span> <span class="toc-text">CubeMap 立方体纹理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bump-Map-%E5%87%B9%E5%87%B8%E8%B4%B4%E5%9B%BE"><span class="toc-number">2.3.6.2.</span> <span class="toc-text">Bump Map 凹凸贴图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Displacement-Map-%E4%BD%8D%E7%A7%BB%E8%B4%B4%E5%9B%BE"><span class="toc-number">2.3.6.3.</span> <span class="toc-text">Displacement Map 位移贴图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-PC%EF%BC%8C%E6%89%8B%E6%9C%BA%E5%9B%BE%E5%BD%A2API%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.4.</span> <span class="toc-text">4.PC，手机图形API介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">2.4.1.</span> <span class="toc-text">基础概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%81%E9%BE%99Adreno%E5%AF%B9%E5%BA%94%E7%9A%84ES%E7%89%88%E6%9C%AC%E5%9E%8B%E5%8F%B7"><span class="toc-number">2.4.2.</span> <span class="toc-text">骁龙Adreno对应的ES版本型号</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">二. 光照基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4"><span class="toc-number">3.1.</span> <span class="toc-text">1.颜色空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%89%E7%9A%84%E5%8F%91%E9%80%81%E8%80%85%E2%80%94%E2%80%94%E5%85%89%E6%BA%90"><span class="toc-number">3.1.1.</span> <span class="toc-text">光的发送者——光源</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%89%E7%9A%84%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94%E6%B3%A2%E9%95%BF"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">光的属性——波长</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%89%E7%9A%84%E5%B1%9E%E6%80%A7%E2%80%94%E2%80%94%E8%83%BD%E9%87%8F%E5%88%86%E5%B8%83"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">光的属性——能量分布</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%89%E7%9A%84%E6%8E%A5%E6%94%B6%E8%80%85%E2%80%94%E2%80%94%E4%BA%BA%E7%9C%BC"><span class="toc-number">3.1.2.</span> <span class="toc-text">光的接收者——人眼</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%AF%B9%E4%BA%AE%E5%BA%A6%E6%84%9F%E7%9F%A5"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">相对亮度感知</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%BA%E7%9C%BCHDR"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">人眼HDR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%BA%E7%9C%BC%E6%84%9F%E5%85%89%E7%BB%86%E8%83%9E%E5%88%86%E5%B8%83"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">人眼感光细胞分布</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%A5%E7%8A%B6%E7%BB%86%E8%83%9E"><span class="toc-number">3.1.2.4.</span> <span class="toc-text">锥状细胞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%BA%E7%9C%BC%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">3.1.2.5.</span> <span class="toc-text">人眼的本质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%BA%E7%9C%BC%E6%8E%A5%E6%94%B6%E5%85%89%E7%9A%84%E5%BE%AE%E7%A7%AF%E5%88%86%E5%85%AC%E5%BC%8F"><span class="toc-number">3.1.2.6.</span> <span class="toc-text">人眼接收光的微积分公式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E7%9A%84%E5%8E%86%E5%8F%B2"><span class="toc-number">3.1.3.</span> <span class="toc-text">颜色空间的历史</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1800%E5%B9%B4%E2%80%94%E2%80%94%E8%89%B2%E5%BD%A9%E7%9A%84%E7%8C%9C%E6%83%B3-swig%EF%BF%BC36"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">1800年——色彩的猜想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1905%E5%B9%B4%E2%80%94%E2%80%94Munsell%E8%89%BA%E6%9C%AF%E5%AE%B6%E8%89%B2%E5%BD%A9%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">1905年——Munsell艺术家色彩系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1931%E5%B9%B4%E2%80%94%E2%80%94CIE%E5%BB%BA%E7%AB%8B%E7%A7%91%E5%AD%A6%E8%89%B2%E5%BD%A9%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.1.3.3.</span> <span class="toc-text">1931年——CIE建立科学色彩系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.3.4.</span> <span class="toc-text">色彩空间的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%89%B2%E5%9F%9F"><span class="toc-number">3.1.3.4.1.</span> <span class="toc-text">1.色域</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Gamma"><span class="toc-number">3.1.3.4.2.</span> <span class="toc-text">2.Gamma</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E7%99%BD%E7%82%B9"><span class="toc-number">3.1.3.4.3.</span> <span class="toc-text">3.白点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sRGB%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4"><span class="toc-number">3.1.3.5.</span> <span class="toc-text">sRGB色彩空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4"><span class="toc-number">3.1.3.6.</span> <span class="toc-text">常用的色彩空间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%9D%90%E8%B4%A8"><span class="toc-number">3.2.</span> <span class="toc-text">2.模型与材质</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">3.2.1.</span> <span class="toc-text">渲染管线与模型基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E%E6%A8%A1%E5%9E%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">与模型相关的渲染管线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E6%90%BA%E5%B8%A6%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">模型携带的信息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%90%E8%B4%A8%E5%9F%BA%E7%A1%80"><span class="toc-number">3.2.2.</span> <span class="toc-text">材质基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%90%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">材质是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%AB%E5%8F%8D%E5%B0%84"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">漫反射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">镜面反射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%98%E5%B0%84"><span class="toc-number">3.2.2.4.</span> <span class="toc-text">折射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B2%97%E7%B3%99%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84"><span class="toc-number">3.2.2.5.</span> <span class="toc-text">粗糙镜面反射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B2%97%E7%B3%99%E9%95%9C%E9%9D%A2%E6%8A%98%E5%B0%84"><span class="toc-number">3.2.2.6.</span> <span class="toc-text">粗糙镜面折射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%B1%82%E7%BA%B9%E7%90%86"><span class="toc-number">3.2.2.7.</span> <span class="toc-text">多层纹理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AC%A1%E8%A1%A8%E9%9D%A2%E6%95%A3%E5%B0%84"><span class="toc-number">3.2.2.8.</span> <span class="toc-text">次表面散射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%B1%82%E7%9A%AE%E8%82%A4%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.2.9.</span> <span class="toc-text">多层皮肤模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E6%9D%90%E8%B4%A8%E8%A1%A8%E9%9D%A2%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.2.10.</span> <span class="toc-text">改变材质表面的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E6%90%BA%E5%B8%A6%E7%9A%84%E6%95%B0%E6%8D%AE%E5%86%8D%E6%B8%B2%E6%9F%93%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.2.3.</span> <span class="toc-text">模型携带的数据再渲染中的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A1%B6%E7%82%B9%E5%8A%A8%E7%94%BB"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">1.顶点动画</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BA%B9%E7%90%86%E5%8A%A8%E7%94%BB"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">2.纹理动画</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%A1%B6%E7%82%B9%E8%89%B2"><span class="toc-number">3.2.3.3.</span> <span class="toc-text">3.顶点色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%8F%92%E5%80%BC%EF%BC%9A%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87"><span class="toc-number">3.2.3.4.</span> <span class="toc-text">4.插值：重心坐标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%A1%B6%E7%82%B9%E6%B3%95%E7%BA%BF%EF%BC%8C%E9%9D%A2%E6%B3%95%E7%BA%BF"><span class="toc-number">3.2.3.5.</span> <span class="toc-text">5.顶点法线，面法线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9ANPR%E6%B8%B2%E6%9F%93%E4%B8%AD%E7%9A%84%E6%8F%8F%E8%BE%B9"><span class="toc-number">3.2.3.6.</span> <span class="toc-text">扩展：NPR渲染中的描边</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%E2%80%94%E2%80%94copy%E8%87%AA-%E8%8B%8F%E6%A0%BC%E6%8B%89%E6%B2%A1%E6%9C%89%E5%BA%95"><span class="toc-number">3.2.3.7.</span> <span class="toc-text">作业——copy自 苏格拉没有底</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%A1%B6%E7%82%B9%E8%89%B2%E7%9A%84%E5%85%B6%E4%BB%96%E4%BD%9C%E7%94%A8"><span class="toc-number">3.2.3.7.1.</span> <span class="toc-text">1.顶点色的其他作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%A8%A1%E5%9E%8B%E5%85%89%E6%BB%91%E7%BB%84%E5%AF%B9%E6%B3%95%E7%BA%BF%E6%9C%89%E4%BB%80%E4%B9%88%E5%BD%B1%E5%93%8D"><span class="toc-number">3.2.3.7.2.</span> <span class="toc-text">2.模型光滑组对法线有什么影响</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D%E2%80%94%E2%80%94HLSL"><span class="toc-number">3.3.</span> <span class="toc-text">3.基础语法介绍——HLSL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97"><span class="toc-number">3.3.1.</span> <span class="toc-text">1.基本数学运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B9%82%E6%8C%87%E5%AF%B9%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.2.</span> <span class="toc-text">2.幂指对函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8C%E6%9B%B2%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.三角函数和双曲函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E7%B1%BB"><span class="toc-number">3.3.4.</span> <span class="toc-text">4.数据范围类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E7%B1%BB"><span class="toc-number">3.3.5.</span> <span class="toc-text">5.类型判断类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%90%91%E9%87%8F%E4%B8%8E%E7%9F%A9%E9%98%B5%E7%B1%BB"><span class="toc-number">3.3.6.</span> <span class="toc-text">6.向量与矩阵类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%85%89%E7%BA%BF%E8%BF%90%E7%AE%97%E7%B1%BB"><span class="toc-number">3.3.7.</span> <span class="toc-text">7.光线运算类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1D%E7%BA%B9%E7%90%86%E6%9F%A5%E6%89%BE"><span class="toc-number">3.3.8.</span> <span class="toc-text">8.1D纹理查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ddx%E5%92%8Cddy%E8%A7%A3%E6%9E%90"><span class="toc-number">3.3.8.1.</span> <span class="toc-text">ddx和ddy解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2D%E7%BA%B9%E7%90%86%E6%9F%A5%E6%89%BE"><span class="toc-number">3.3.9.</span> <span class="toc-text">9.2D纹理查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3D%E7%BA%B9%E7%90%86%E6%9F%A5%E6%89%BE"><span class="toc-number">3.3.10.</span> <span class="toc-text">10.3D纹理查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-CubeMap%E7%BA%B9%E7%90%86%E6%9F%A5%E6%89%BE"><span class="toc-number">3.3.11.</span> <span class="toc-text">11.CubeMap纹理查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A"><span class="toc-number">3.3.12.</span> <span class="toc-text">作业</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ddx%E5%92%8Cddy%E7%9A%84%E5%AE%9E%E9%99%85%E7%94%A8%E5%A4%84%E2%80%94%E2%80%94%E8%8B%8F%E6%A0%BC%E6%8B%89%E6%B2%A1%E6%9C%89%E5%BA%95"><span class="toc-number">3.3.12.1.</span> <span class="toc-text">ddx和ddy的实际用处——苏格拉没有底</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BC%A0%E7%BB%9F%E7%BB%8F%E9%AA%8C%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.4.</span> <span class="toc-text">4.传统经验光照模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.4.1.</span> <span class="toc-text">局部光照模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%85%89%E6%BA%90%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">局部光源的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%AB%E5%8F%8D%E5%B0%84-2"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">漫反射</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Lambert%E4%BD%99%E5%BC%A6%E5%AE%9A%E7%90%86"><span class="toc-number">3.4.1.2.1.</span> <span class="toc-text">Lambert余弦定理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E5%85%89%E5%8F%8D%E5%B0%84"><span class="toc-number">3.4.1.3.</span> <span class="toc-text">高光反射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%85%89"><span class="toc-number">3.4.1.4.</span> <span class="toc-text">环境光</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8F%91%E5%85%89"><span class="toc-number">3.4.1.5.</span> <span class="toc-text">自发光</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%85%89%E7%85%A7%E7%9A%84%E6%95%B4%E4%BD%93%E6%95%88%E6%9E%9C"><span class="toc-number">3.4.1.6.</span> <span class="toc-text">局部光照的整体效果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Lambert%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.4.1.7.</span> <span class="toc-text">1.Lambert模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Phong%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.4.1.8.</span> <span class="toc-text">2.Phong模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Blinn-Phong%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.4.1.9.</span> <span class="toc-text">3.Blinn-Phong模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Phong%E5%92%8CBlinn-Phong%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.4.1.10.</span> <span class="toc-text">Phong和Blinn-Phong模型的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9D%80%E8%89%B2%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.4.2.</span> <span class="toc-text">着色模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Gouraud-Shading%E2%80%94%E2%80%94%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">Gouraud Shading——顶点着色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Flat-Shading%E2%80%94%E2%80%94%E9%9D%A2%E7%9D%80%E8%89%B2"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">Flat Shading——面着色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Phong-Shading%E2%80%94%E2%80%94%E7%89%87%E5%85%83%E7%9D%80%E8%89%B2"><span class="toc-number">3.4.2.3.</span> <span class="toc-text">Phong Shading——片元着色</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IBL%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E5%85%89%E7%85%A7"><span class="toc-number">3.4.3.</span> <span class="toc-text">IBL——基于图像的光照</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Bump-Map%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-number">3.5.</span> <span class="toc-text">5.Bump Map的改进</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%B9%E5%87%B8%E6%98%A0%E5%B0%84"><span class="toc-number">3.5.1.</span> <span class="toc-text">什么是凹凸映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Normal-Mapping-%E6%B3%95%E7%BA%BF%E6%98%A0%E5%B0%84"><span class="toc-number">3.5.2.</span> <span class="toc-text">Normal Mapping 法线映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%BA%BF%E7%A9%BA%E9%97%B4%E5%88%B0%E4%B8%96%E7%95%8C%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.5.2.1.</span> <span class="toc-text">切线空间到世界空间转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%BA%BF%E7%A9%BA%E9%97%B4%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">3.5.2.2.</span> <span class="toc-text">切线空间的好处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Unity%E4%B8%AD%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE%E7%9A%84%E5%8E%8B%E7%BC%A9%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.5.2.3.</span> <span class="toc-text">Unity中法线贴图的压缩格式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallax-Mapping-%E8%A7%86%E5%B7%AE%E6%98%A0%E5%B0%84"><span class="toc-number">3.5.3.</span> <span class="toc-text">Parallax Mapping 视差映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%86%E5%B7%AE%E6%98%A0%E5%B0%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.5.3.1.</span> <span class="toc-text">视差映射基本实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%A1%E5%B3%AD%E8%A7%86%E5%B7%AE%E6%98%A0%E5%B0%84"><span class="toc-number">3.5.3.2.</span> <span class="toc-text">陡峭视差映射</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Relief-Mapping-%E6%B5%AE%E9%9B%95%E6%98%A0%E5%B0%84"><span class="toc-number">3.5.4.</span> <span class="toc-text">Relief Mapping 浮雕映射</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Gamma%E7%9F%AB%E6%AD%A3"><span class="toc-number">3.6.</span> <span class="toc-text">6.Gamma矫正</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFGamma%E7%9F%AB%E6%AD%A3"><span class="toc-number">3.6.1.</span> <span class="toc-text">什么是Gamma矫正</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81Gamma%E7%BC%96%E7%A0%81%E5%92%8C%E7%9F%AB%E6%AD%A3"><span class="toc-number">3.6.2.</span> <span class="toc-text">为什么需要Gamma编码和矫正</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CRT%E2%80%94%E2%80%94%E9%98%B4%E6%9E%81%E5%B0%84%E7%BA%BF%E6%98%BE%E5%83%8F%E7%AE%A1"><span class="toc-number">3.6.3.</span> <span class="toc-text">CRT——阴极射线显像管</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E7%81%B0%E5%80%BC"><span class="toc-number">3.6.4.</span> <span class="toc-text">中灰值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="toc-number">3.6.5.</span> <span class="toc-text">线性工作流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Unity%E4%B8%AD%E9%80%89%E6%8B%A9%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4"><span class="toc-number">3.6.5.1.</span> <span class="toc-text">Unity中选择颜色空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SubstancePainter%E5%AF%BC%E5%87%BA%E7%9A%84%E8%B4%B4%E5%9B%BE"><span class="toc-number">3.6.5.2.</span> <span class="toc-text">SubstancePainter导出的贴图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PhotoShop%E5%AF%BC%E5%87%BA%E7%9A%84%E8%B4%B4%E5%9B%BE"><span class="toc-number">3.6.5.3.</span> <span class="toc-text">PhotoShop导出的贴图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-LDR%E5%92%8CHDR"><span class="toc-number">3.7.</span> <span class="toc-text">7.LDR和HDR</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4"><span class="toc-number">3.7.1.</span> <span class="toc-text">动态范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.7.2.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81HDR"><span class="toc-number">3.7.3.</span> <span class="toc-text">为什么需要HDR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unity%E4%B8%AD%E7%9A%84HDR"><span class="toc-number">3.7.4.</span> <span class="toc-text">Unity中的HDR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HDR%E5%92%8CBloom"><span class="toc-number">3.7.5.</span> <span class="toc-text">HDR和Bloom</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Unity%E4%B8%ADBloom%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">3.7.5.1.</span> <span class="toc-text">Unity中Bloom的流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HDR%E5%92%8CTone-Mapping"><span class="toc-number">3.7.6.</span> <span class="toc-text">HDR和Tone Mapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LUT%E2%80%94%E2%80%94Look-Up-Table"><span class="toc-number">3.7.7.</span> <span class="toc-text">LUT——Look Up Table</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Flow-Map%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.8.</span> <span class="toc-text">8.Flow Map的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFFlowMap"><span class="toc-number">3.8.1.</span> <span class="toc-text">什么是FlowMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FlowMap%E7%9A%84Shader%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.8.2.</span> <span class="toc-text">FlowMap的Shader实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FlowMap%E7%BA%B9%E7%90%86%E7%9A%84%E5%88%B6%E4%BD%9C%E5%B7%A5%E5%85%B7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">3.8.3.</span> <span class="toc-text">FlowMap纹理的制作工具和方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Flowmap-painter"><span class="toc-number">3.8.3.1.</span> <span class="toc-text">Flowmap painter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Houdini%E5%88%B6%E4%BD%9CFlowMap%E2%80%94%E2%80%94%EF%BC%88%E6%9C%AA%E7%9C%8B%EF%BC%89"><span class="toc-number">3.8.3.2.</span> <span class="toc-text">Houdini制作FlowMap——（未看）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-GPU%E7%A1%AC%E4%BB%B6%E6%9E%B6%E6%9E%84"><span class="toc-number">3.9.</span> <span class="toc-text">9.GPU硬件架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%BE%97%E5%BE%88%E5%A5%BD%E7%9A%84%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%99%93%E7%97%95"><span class="toc-number">3.9.1.</span> <span class="toc-text">写得很好的笔记——晓痕</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GPU%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.9.2.</span> <span class="toc-text">GPU是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GPU%E6%9E%B6%E6%9E%84%E7%9A%84%E5%85%B3%E9%94%AE%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2"><span class="toc-number">3.9.3.</span> <span class="toc-text">GPU架构的关键发展历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GPU%E5%BE%AE%E8%A7%82%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">3.9.4.</span> <span class="toc-text">GPU微观物理结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GPU%E5%AE%8C%E6%95%B4%E7%9A%84%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B"><span class="toc-number">3.9.5.</span> <span class="toc-text">GPU完整的渲染流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Early-Z"><span class="toc-number">3.9.6.</span> <span class="toc-text">Early-Z</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GPU%E7%9A%84%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="toc-number">3.9.7.</span> <span class="toc-text">GPU的优化技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SIMD"><span class="toc-number">3.9.7.1.</span> <span class="toc-text">SIMD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SIMT"><span class="toc-number">3.9.7.2.</span> <span class="toc-text">SIMT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#co-issue"><span class="toc-number">3.9.7.3.</span> <span class="toc-text">co-issue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GPU%E8%B5%84%E6%BA%90%E6%9C%BA%E5%88%B6"><span class="toc-number">3.9.8.</span> <span class="toc-text">GPU资源机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GPU%E7%9A%84%E5%86%85%E5%AD%98%E6%9E%B6%E6%9E%84"><span class="toc-number">3.9.8.1.</span> <span class="toc-text">GPU的内存架构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shader%E8%BF%90%E8%A1%8C%E5%9C%A8%E7%A1%AC%E4%BB%B6%E5%B1%82%E9%9D%A2%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.9.9.</span> <span class="toc-text">Shader运行在硬件层面的理解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">三. 进阶应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E5%92%8C%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95"><span class="toc-number">4.1.</span> <span class="toc-text">1.深度测试和模板测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95-Stencil-Test"><span class="toc-number">4.1.1.</span> <span class="toc-text">1.模板测试 Stencil Test</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E7%9A%84%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3%E5%92%8C%E6%95%88%E6%9E%9C"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">模板测试的初步理解和效果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">模板测试是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BB%8E%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%9D%A5%E7%9C%8B%EF%BC%8C%E7%BB%8F%E8%BF%87%E7%89%87%E5%85%83%E7%9D%80%E8%89%B2%E5%99%A8%E5%90%8E%E7%9A%84%E9%98%B6%E6%AE%B5"><span class="toc-number">4.1.1.2.1.</span> <span class="toc-text">1.从渲染管线来看，经过片元着色器后的阶段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BB%8E%E9%80%BB%E8%BE%91%E4%B8%8A%E7%90%86%E8%A7%A3"><span class="toc-number">4.1.1.2.2.</span> <span class="toc-text">2.从逻辑上理解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BB%8E%E6%A6%82%E5%BF%B5%E4%B8%8A%E7%90%86%E8%A7%A3"><span class="toc-number">4.1.1.2.3.</span> <span class="toc-text">3.从概念上理解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Unity-Shader%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95"><span class="toc-number">4.1.1.3.</span> <span class="toc-text">Unity Shader中使用模板测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E6%89%A9%E5%B1%95"><span class="toc-number">4.1.1.4.</span> <span class="toc-text">模板测试扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95Demo"><span class="toc-number">4.1.1.5.</span> <span class="toc-text">模板测试Demo</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95-Z-Test"><span class="toc-number">4.1.2.</span> <span class="toc-text">2.深度测试 Z Test</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">深度测试是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BB%8E%E9%80%BB%E8%BE%91%E4%B8%8A%E7%90%86%E8%A7%A3"><span class="toc-number">4.1.2.1.1.</span> <span class="toc-text">1.从逻辑上理解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BB%8E%E6%A6%82%E5%BF%B5%E4%B8%8A%E7%90%86%E8%A7%A3"><span class="toc-number">4.1.2.1.2.</span> <span class="toc-text">2.从概念上理解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BB%8E%E6%B8%B2%E6%9F%93%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2%E7%90%86%E8%A7%A3"><span class="toc-number">4.1.2.1.3.</span> <span class="toc-text">2.从渲染的发展历史理解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2%E5%8C%BA-Z-Buffer"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">深度缓冲区 Z-Buffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Z-Write"><span class="toc-number">4.1.2.3.</span> <span class="toc-text">Z Write</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Z-Test%E7%9A%84%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.2.4.</span> <span class="toc-text">Z Test的比较函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E9%98%9F%E5%88%97%E2%80%94%E2%80%94Unity%E4%B8%AD"><span class="toc-number">4.1.2.5.</span> <span class="toc-text">渲染队列——Unity中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0Early-Z%E6%8A%80%E6%9C%AF"><span class="toc-number">4.1.2.6.</span> <span class="toc-text">简述Early-Z技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Z-Buffer%E4%B8%AD%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%80%BC%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%9A%84%EF%BC%9F"><span class="toc-number">4.1.2.7.</span> <span class="toc-text">Z-Buffer中的深度值为什么是非线性的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E5%86%B2%E7%AA%81"><span class="toc-number">4.1.2.8.</span> <span class="toc-text">深度冲突</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95Demo"><span class="toc-number">4.1.2.9.</span> <span class="toc-text">深度测试Demo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E6%89%A9%E5%B1%95"><span class="toc-number">4.1.2.10.</span> <span class="toc-text">深度测试扩展</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%89%94%E9%99%A4"><span class="toc-number">4.2.</span> <span class="toc-text">2.混合模式及剔除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.2.1.</span> <span class="toc-text">什么是混合模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%91%A2"><span class="toc-number">4.2.2.</span> <span class="toc-text">混合模式有哪些呢</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PS%E4%B8%AD%E7%9A%84%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">PS中的混合模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ShaderLab%E4%B8%AD%E7%9A%84%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">ShaderLab中的混合模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Blend%E5%92%8CBlend-Op"><span class="toc-number">4.2.2.3.</span> <span class="toc-text">Blend和Blend Op</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84Blend%E5%91%BD%E4%BB%A4"><span class="toc-number">4.2.2.3.1.</span> <span class="toc-text">常见的Blend命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BlendOp"><span class="toc-number">4.2.2.3.2.</span> <span class="toc-text">BlendOp</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Unity%E9%87%8CBlend%E6%9E%9A%E4%B8%BE%E5%8F%98%E9%87%8F%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%AD%E6%B3%95"><span class="toc-number">4.2.2.3.3.</span> <span class="toc-text">Unity里Blend枚举变量序列化语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E6%B7%B7%E5%90%88%E6%95%88%E6%9E%9C%E5%AE%9E%E4%BE%8B"><span class="toc-number">4.2.2.3.4.</span> <span class="toc-text">各种混合效果实例</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Normal%E6%AD%A3%E5%B8%B8"><span class="toc-number">4.2.2.3.4.1.</span> <span class="toc-text">Normal正常</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Darken%E5%8F%98%E6%9A%97"><span class="toc-number">4.2.2.3.4.2.</span> <span class="toc-text">Darken变暗</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Multipy%E6%AD%A3%E7%89%87%E5%8F%A0%E5%BA%95"><span class="toc-number">4.2.2.3.4.3.</span> <span class="toc-text">Multipy正片叠底</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Screen%E6%BB%A4%E8%89%B2"><span class="toc-number">4.2.2.3.4.4.</span> <span class="toc-text">Screen滤色</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Lighten%E5%8F%98%E4%BA%AE"><span class="toc-number">4.2.2.3.4.5.</span> <span class="toc-text">Lighten变亮</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#LinearDodge%E7%BA%BF%E6%80%A7%E5%87%8F%E6%B7%A1"><span class="toc-number">4.2.2.3.4.6.</span> <span class="toc-text">LinearDodge线性减淡</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#ColorBurn%E9%A2%9C%E8%89%B2%E5%8A%A0%E6%B7%B1"><span class="toc-number">4.2.2.3.4.7.</span> <span class="toc-text">ColorBurn颜色加深</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%94%E9%99%A4"><span class="toc-number">4.2.3.</span> <span class="toc-text">剔除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%9B%B2%E9%9D%A2%E7%BB%86%E5%88%86%E7%9D%80%E8%89%B2%E5%99%A8%E4%B8%8E%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">4.3.</span> <span class="toc-text">3.曲面细分着色器与几何着色器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">4.3.1.</span> <span class="toc-text">渲染管线中的顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B2%E9%9D%A2%E7%BB%86%E5%88%86%E7%9D%80%E8%89%B2%E5%99%A8-Tessellation-Shader"><span class="toc-number">4.3.2.</span> <span class="toc-text">曲面细分着色器 Tessellation Shader</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TESS%E7%9A%84%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">TESS的输入和输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TESS%E7%9A%84%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">TESS的渲染流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hull-Shader%E9%83%A8%E5%88%86"><span class="toc-number">4.3.2.3.</span> <span class="toc-text">Hull Shader部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B2%E9%9D%A2%E7%BB%86%E5%88%86%E7%9D%80%E8%89%B2%E5%99%A8%E7%9A%84Demo"><span class="toc-number">4.3.2.4.</span> <span class="toc-text">曲面细分着色器的Demo</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%BB%86%E5%88%86%E4%B8%80%E4%B8%AAQuad"><span class="toc-number">4.3.2.4.1.</span> <span class="toc-text">1.细分一个Quad</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%BB%86%E5%88%86%E7%9D%80%E8%89%B2%E5%99%A8%E9%85%8D%E5%90%88displacement%E8%B4%B4%E5%9B%BE"><span class="toc-number">4.3.2.4.2.</span> <span class="toc-text">2.细分着色器配合displacement贴图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8-Geometry-Shader"><span class="toc-number">4.3.3.</span> <span class="toc-text">几何着色器 Geometry Shader</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GS%E7%9A%84%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="toc-number">4.3.3.1.</span> <span class="toc-text">GS的输入和输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8%E7%9A%84Demo"><span class="toc-number">4.3.3.2.</span> <span class="toc-text">几何着色器的Demo</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%B8%89%E8%A7%92%E5%BD%A2%E7%94%9F%E6%88%90%E7%AE%80%E5%8D%95%E7%9A%84%E8%8D%89"><span class="toc-number">4.3.3.2.1.</span> <span class="toc-text">1.三角形生成简单的草</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%80%85%E6%90%AD%E9%85%8D%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E8%8D%89%E5%9C%B0%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">4.3.4.</span> <span class="toc-text">二者搭配实现一个完整的草地（重点）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">四. 高级扩展</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">五. 物理世界</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">六. 非真实感渲染</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">七. 其他</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/07/3D-Reconstruction/" title="3D-Reconstruction">3D-Reconstruction</a><time datetime="2024-12-06T16:00:00.000Z" title="发表于 2024-12-07 00:00:00">2024-12-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/19/Clouduo-Demo/" title="Clouduo作品集">Clouduo作品集</a><time datetime="2024-10-18T16:00:00.000Z" title="发表于 2024-10-19 00:00:00">2024-10-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/19/TA-Graphics/" title="技术美术百人计划-图形向笔记">技术美术百人计划-图形向笔记</a><time datetime="2024-10-18T16:00:00.000Z" title="发表于 2024-10-19 00:00:00">2024-10-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/19/CS61C/" title="CS61C-笔记">CS61C-笔记</a><time datetime="2024-09-18T16:00:00.000Z" title="发表于 2024-09-19 00:00:00">2024-09-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/19/MSC%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/" title="MSC-GAMECLUB 游戏开发学习资源（持续更新...）">MSC-GAMECLUB 游戏开发学习资源（持续更新...）</a><time datetime="2023-10-18T16:00:00.000Z" title="发表于 2023-10-19 00:00:00">2023-10-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Clouduo</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>